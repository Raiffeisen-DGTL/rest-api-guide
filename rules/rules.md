# API Best Practices 

- [API Best Practices](#api-best-practices)
    - [Введение](#введение)
- [Общие рекомендации](#общие-рекомендации)
    - [Использование kebab-case для пути](#использование-kebab-case-для-пути)
      - [Описание правила](#описание-правила)
      - [Обоснование](#обоснование)
    - [Избегать избыточных префиксов в пути](#избегать-избыточных-префиксов-в-пути)
      - [Описание правила](#описание-правила-1)
      - [Обоснование](#обоснование-1)
    - [Используем для именования параметров запроса camelCase](#используем-для-именования-параметров-запроса-camelcase)
      - [Описание правила](#описание-правила-2)
      - [Обоснование](#обоснование-2)
    - [Используем для именования полей тела запроса camelCase](#используем-для-именования-полей-тела-запроса-camelcase)
      - [Описание правила](#описание-правила-3)
      - [Обоснование](#обоснование-3)
    - [Используем lowerCamelCase для operationId метода](#используем-lowercamelcase-для-operationid-метода)
      - [Описание правила](#описание-правила-4)
      - [Обоснование](#обоснование-4)
    - [Выносим тело запроса и ответа методов в отдельный блок](#выносим-тело-запроса-и-ответа-методов-в-отдельный-блок)
      - [Описание правила](#описание-правила-5)
      - [Обоснование](#обоснование-5)
    - [Объекты запросов и ответов именуются стилем CamelCase с постфиксами `Request/Response`](#объекты-запросов-и-ответов-именуются-стилем-camelcase-с-постфиксами-requestresponse)
      - [Описание правила](#описание-правила-6)
      - [Обоснование](#обоснование-6)
    - [Выделяем части запросов/ответов в отдельные объекты](#выделяем-части-запросовответов-в-отдельные-объекты)
      - [Описание правила](#описание-правила-7)
      - [Обоснование](#обоснование-7)
    - [Используем UPPER\_SNAKE\_CASE для Enum и mapping для discriminator](#используем-upper_snake_case-для-enum-и-mapping-для-discriminator)
      - [Описание правила](#описание-правила-8)
      - [Обоснование](#обоснование-8)
    - [Пагинация](#пагинация)
      - [offset-пагинация (page,size)](#offset-пагинация-pagesize)
        - [Описание правила](#описание-правила-9)
      - [курсор-пагинация](#курсор-пагинация)
        - [Описание правила](#описание-правила-10)
    - [Сортировка](#сортировка)
      - [Описание правила](#описание-правила-11)
    - [Фильтрация](#фильтрация)
      - [Описание правила](#описание-правила-12)
    - [Используй формат даты-времени ISO 8601](#используй-формат-даты-времени-iso-8601)
      - [Описание правила](#описание-правила-13)
      - [Обоснование](#обоснование-9)
    - [используй формат стран ISO 3166](#используй-формат-стран-iso-3166)
      - [Описание правила](#описание-правила-14)
      - [Обоснование](#обоснование-10)
    - [используй формат стран ISO 4217](#используй-формат-стран-iso-4217)
      - [Описание правила](#описание-правила-15)
      - [Обоснование](#обоснование-11)
    - [Используй версионирование в URL](#используй-версионирование-в-url)
      - [Описание правила](#описание-правила-16)
      - [Обоснование](#обоснование-12)
    - [Учитывай обратную совместимость API](#учитывай-обратную-совместимость-api)
      - [Описание правила](#описание-правила-17)
      - [Обоснование](#обоснование-13)


### Введение

Данный гайд содержит основные принципы и правила, которым мы следуем при разработке REST API в Райффайзен Банке. 
Правила разделены по тематическим разделам.
У каждого правила есть:

- *ID* - уникальный идентификатор правила
- *Severity* - индикатор, является ли правило обязательным(MUST) или рекомендацией(RECOMMENDATION)
- *Дата принятия* - когда это правило было добавлено в гайд

# Общие рекомендации

REST ([Representational State Transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)) - это архитектурная абстракция, которая описывает взаимодействией компонентов в распределенной системе. REST широко используется для создания web API (*RESTful web API*), которое использует протокол HTTP как транспорт.

В RESTful web API обращение к ресурсу происходит по уникальному идентификатору (*URL*), с указанием действия над ресурсом (*HTTP method*), в запросе может передаваться тело запроса (*body*) и дополнительные заголовки (*HTTP header fields*). В ответ на запрос, ресурс возвращает код ответа (*HTTP status code*) и **может** возвращаться тело ответа.

В качество формата тела запроса/ответа рекомендуется использовать только JSON. Использование других форматов (XML/TXT) возможно в исключительных случаях.

Мы ориентируемся на [Richardson Maturity Model](https://martinfowler.com/articles/richardsonMaturityModel.html), но считаем избыточным Level 3


---

### Использование kebab-case для пути 

| ID              | Severity | Дата принятия |
|-----------------|----------|---------------|
| path-kebab-case | MUST     | 27.02.2025    |

#### Описание правила

Пути API должны использовать kebab-case (строчные буквы с разделением дефисами) для наименования.

Правильно:
```
/v1/statements
/v1/payment-orders/
```
Неправильно:
```
/v1/paymentOrders    // camelCase
/v1/PaymentOrders    // PascalCase
/v1/payment_orders   // snake_case

```
#### Обоснование

Использование kebab-case обеспечивает единообразие API и соответствует лучшим практикам именования ресурсов в REST API. 
Чтобы ваши URI было легче сканировать и интерпретировать, используйте символ дефиса (-), чтобы улучшить читаемость имен в сегментах длинных путей.

Были рассмотрены альтернативные стили именования:
- camelCase - отклонён из-за проблем с регистро-зависимостью в некоторых системах
- snake_case - отклонён для сохранения единообразия
- PascalCase - отклонён из-за проблем с читаемостью URL

---

### Избегать избыточных префиксов в пути

| ID                         | Severity | Дата принятия |
|----------------------------|----------|---------------|
| path-no-redundant-prefixes | MUST     | 27.02.2025    |


#### Описание правила

Не следует использовать избыточные термины, не относящиеся к смыслу ресурса/команды, такие как:
- `api`
- `openapi`
- `http`
- `service`

> При публикации внешних API допускается префикс `/api` на уровне gateway канала, например `pay.raif.ru/api/...`, подробнее см. [Следуйте структуре пути API](#следуйте-структуре-пути-api)

Правильно:
```
/v1/statements
/v1/statements/export

```

Неправильно:
```
/api/v1/statements
/v1/http/statements
/v1/statement-service/export
```

#### Обоснование

Избыточные префиксы увеличивают длину URL без добавления смысловой нагрузки, усложняют чтение и понимание API.

При публикации для внешних клиентов на `api.raiffeisen.ru` дополнительный префикс `api` будет создавать избыточность. 

---

### Используем для именования параметров запроса camelCase

| ID                      | Severity | Дата принятия |
|-------------------------|----------|---------------|
| query-params-camel-case | MUST     | 27.02.2025    |


#### Описание правила

Используем для именования параметров [camelCase](https://en.wiktionary.org/wiki/CamelCase). 


Правильно:
```
/v1/statements?requestId={requestId}
```

Неправильно:
```
/v1/statements?request_id={requestId}
/v1/statements?RequestId={requestId}
```

#### Обоснование

Самым популярным решением для query params в банке является `camelCase`, именно поэтому выбран стандартным способом именования.

---

### Используем для именования полей тела запроса camelCase

| ID                      | Severity | Дата принятия |
|-------------------------|----------|---------------|
| body-fields-camel-case  | MUST     | 11.03.2025    |


#### Описание правила

Используем для именования полей тела запроса [camelCase](https://en.wiktionary.org/wiki/CamelCase). 


Правильно:
```json
{
  "productId": "8AD369C0-68B4-4CD2-B78B-413D53AD1E82",
  "price": 50,
  "createdAt": "2025-03-11T09:14:38+03:00"
  ...
}
```

Неправильно:
```json
{
  "product_id": "8AD369C0-68B4-4CD2-B78B-413D53AD1E82",
  "UpdatedAt": "2025-03-11T11:12:38+03:00",
  "createdat": "2025-03-11T09:14:38+03:00"
  ...
}
```

#### Обоснование

Самым популярным решением для полей тела запроса в банке является `camelCase`, именно поэтому выбран стандартным способом именования. Такое же способ именования используется в параметрах запроса - [Используем для именования параметров запроса camelCase](#используем-для-именования-параметров-запроса-camelcase)

---

### Используем lowerCamelCase для operationId метода
| ID                              | Severity | Дата принятия |
|---------------------------------|----------|---------------|
| method-operation-id-camel-case  | MUST     | 13.03.2025    |

#### Описание правила

`operationId` - lowerCamelCase, содержит в себе короткое название метода (например, `createOrder` или `getPaymentStatus`).

Правильно:
```yaml
paths:
  '/sbp/v2/qrs/':
    post:
      operationId: registerQR
  ...
```

Неправильно:
```yaml
paths:
  '/sbp/v2/qrs/':
    post:
      operationId: post-sbp-v2-qrs
  ...
```

#### Обоснование
Согласно назначению в спецификации [openapi](https://swagger.io/specification/) поле может использоваться тулами и библиотеками для уникального обозначения метода в коде. Спецификация рекомендует именовать согласоно соглашения о именовании языка программирования. У нас самый популярный язык - это Java, в ней принято использовать для именования методов lowerCamelCase

---

### Выносим тело запроса и ответа методов в отдельный блок
| ID                                  | Severity | Дата принятия |
|-------------------------------------|----------|---------------|
| method-request-response-components  | MUST     | 13.03.2025    |

#### Описание правила
Тело запроса и ответа должны быть вынесены в блок [Components Object](https://spec.openapis.org/oas/v3.1.0#components-object) как [Schema](https://spec.openapis.org/oas/v3.1.0#schema).

Правильно:
```yaml
paths:
  '/sbp/v2/qrs/':
    post:
      requestBody: 
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/reqPayQR'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/qrResponse'
```

Неправильно:
```yaml
paths:
  '/sbp/v2/qrs/':
    post:
      requestBody: 
        content:
          application/json:
            schema:
              type: object
              properties: 
                qrId:
                  type: string
                  ...
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: object
                properties: 
                  qrId:
                    type: string
                    ...
```
#### Обоснование
- Улучшает читаемость спецификации тогда как средства отображения АПИ в любом случае позволяют скрывать и раскрывать содержание запросов и ответов.
- Возможность переиспользования объектов запросов и ответов

---

### Объекты запросов и ответов именуются стилем CamelCase с постфиксами `Request/Response`
| ID                               | Severity | Дата принятия |
|----------------------------------|----------|---------------|
| object-request-response-postfix  | MUST     | 13.03.2025    |

#### Описание правила
Объекты запросов и ответов именуются стилем CamelCase с постфиксами `Request/Response` (например, `CreateOrderRequest`). Исключение составляет случай, когда модель присутствует и в запросе, и в ответе. Тогда постфикс опускается.

#### Обоснование
Улучшает читаемость и структурированность спецификации

---

### Выделяем части запросов/ответов в отдельные объекты
| ID                                  | Severity | Дата принятия |
|-------------------------------------|----------|---------------|
| object-request-response-extraction  | MUST     | 13.03.2025    |

#### Описание правила
- Все объекты, которые используются больше одного раза, должны быть вынесены как отдельные модели/параметры. Их использование происходит с помощью [ссылок](https://spec.openapis.org/oas/v3.1.0#reference-object) `$ref`.

Правильно
```yaml
    orderCreationResponse:
      properties:
        status:
          $ref: '#/components/schemas/Status'
    orderCreationResponse:
      properties:
        status:
          $ref: '#/components/schemas/Status'
    Status:
      type: object
      properties:
        value:
          type: string
          enum:
            - NEW
            - CANCELLED
            - EXPIRED
            - PAID
          description: Статус
        date:
          type: string
          format: date-time
          description: Дата создания заказа

```

Неправильно
```yaml
    orderCreationResponse:
      properties:
        status:
          type: object
          properties:
            value:
              type: string
              enum:
                - NEW
                - CANCELLED
                - EXPIRED
                - PAID
              description: Статус
            date:
              type: string
              format: date-time
              description: Дата создания заказа
    orderCreationResponse:
      properties:
        status:
          type: object
          properties:
            value:
              type: string
              enum:
                - NEW
                - CANCELLED
                - EXPIRED
                - PAID
              description: Статус
            date:
              type: string
              format: date-time
              description: Дата создания заказа
```

#### Обоснование
Следование принципу [DRY](https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself)

---

### Используем UPPER_SNAKE_CASE для Enum и mapping для discriminator
| ID                                    | Severity | Дата принятия |
|---------------------------------------|----------|---------------|
| enum-discriminator-upper-snaker-case  | MUST     | 13.03.2025    |

#### Описание правила
Перечисления и значения маппинга для дискриминатора именуются UPPER_SNAKE_CASE

Правильно
```yaml
properties:
  value:
    type: string
    enum:
      - NEW_ORDER
      - CANCELLED
      - EXPIRED
      - PAID
```
Неправильно
```yaml
properties:
  value:
    type: string
    enum:
      - NewOreder
      - expired-order
      - paid_order
```

#### Обоснование
В большенстве ЯП константы и перечисления именуются UPPER_SNAKE_CASE, для поддержания единобразия в спецификации стоит делать так же.

---

### Пагинация

#### offset-пагинация (page,size)
| ID                 | Severity | Дата принятия |
|--------------------|----------|---------------|
| offset-pagination  | MUST     | 13.03.2025    |

##### Описание правила
Для небольших объемов данных, которые редко изменяются, рекомендуется использовать offset-пагинацию (page, size).
Параметр запроса "page" указывает на 1-based номер страницы, "size" - на максимальный размер возвращаемого массива.

Запрос:
```
GET /api/sbp/v1/products?name=potato&page=2&size=20
```
В случае сложных фильтров:
```
POST /api/sbp/v1/products/search
```
```json
{
    "filter": "some filter",
    "paging": {
        "page": 2,
        "size": 20
    }
}
```

Ответ кроме самих данных содержит общее число страниц, число элементов и флаг наличия следующей страницы:
```json
{
    "content": ["foo", "bar"],
    "totalPages": 2,
    "totalElements": 21,
    "last": true
}
```

---

#### курсор-пагинация
| ID                 | Severity | Дата принятия |
|--------------------|----------|---------------|
| cursor-pagination  | MUST     | 13.03.2025    |

##### Описание правила

Для больших или быстро меняющихся наборов данных, лучше использовать курсор-пагинацию.
Для значения курсора следует использовать уникальный индексированный набор полей.
Например, дату создания записи. Для унификации значение курсора кодируется в base64.

Запрос первой страницы может быть без явного указания курсора:
```
GET /api/sbp/v1/products?limit=20
```

Ответ должен содержать значение курсора начала следующей страницы:
```json
{
    "content": [],
    "nextCursor": "ewogICJjcmVhdGVkIjogIjIwMjMtMDctMjJUMDk6MTQ6MzgrMDM6MDAiCn0="
}
```

Запрос следующей страницы со значеним курсора:
```
GET /api/sbp/v1/products?cursor=ewogICJjcmVhdGVkIjogIjIwMjMtMDctMjJUMDk6MTQ6MzgrMDM6MDAiCn0%3D&limit=20
```

Если записей больше нет, nextCursor должен быть пустым:
```json
{
    "content": [{
        "id": 123
    }],
    "nextCursor": ""
}
```

При необходимости сортировки данных, их следует добавлять в курсор.
Запрос:
```
GET /api/sbp/v1/products?sortBy=price,name&limit=20
```
Ответ:
```json
{
    "content": [{
        "id": 123
    }],
    "nextCursor": "ewogICJwcmljZSI6IDEyLjAxLAogICJuYW1lIiwgInBvdGF0byIsCiAgImNyZWF0ZWQiOiAiMjAyMy0wNy0yMlQwOToxNDozOCswMzowMCIKfQ"
}
```

---

### Сортировка
| ID                 | Severity | Дата принятия |
|--------------------|----------|---------------|
| sorting  | MUST     | 13.03.2025    |


#### Описание правила

В общем случае, клиент не должен полагаться на сортировку результата сервером, за исключением случаев, когда документация на API явно описывает сортировку по-умолчанию.

В случаях когда запрос возвращает небольшую выборку, более предпочтительным вариантом может оказаться сортировка на стороне клиента.

В случаях когда запрос возвращает небольшую выборку, более предпочтительным вариантом может оказаться сортировка на стороне клиента.

Если требуется сортировка по одному полю, то рекомендуем указывать поле для сортировки в параметре **sortBy** и порядок сортировки в параметре **orderBy** (asc/desc).

$`\textcolor{green}{\text{Правильно:}}`$  

```
GET /api/v1/products?sortBy=price&orderBy=desc
```

$`\textcolor{red}{\text{Неправильно:}}`$  

```
GET /api/v1/users?sort=-created_at,+username

GET /api/v1/products?sortby=price_asc&date_desc

GET /api/v1/users?sort={"created_at":"desc","username":"asc"}
```

Если параметр **orderBy** не указан, то по-умолчанию предполагается сортировка по возрастанию (*asc*).

В сложных случаях, когда требуется сортировка по нескольким полях в сочетании со сложными фильтрами и(или) пагинацией, рекомендуем использовать метод POST.

$`\textcolor{green}{\text{Рекомендуем:}}`$  

```
POST /api/v1/users/search
{
    "filter": "some filter",
    "paging": {
        "offset": 50,
        "limit": 20
    },
    "order": [
      {  "priority": 1,
         "sortBy": "created_at",
         "orderBy": "desc"
      },
      {  "priority": 2,
         "sortBy": "username",
         "orderBy": "asc"
      }
    ]
}
```

---

### Фильтрация
| ID                      | Severity | Дата принятия |
|-------------------------|----------|---------------|
| filtering               | MUST     | 18.03.2025    |

#### Описание правила

По умолчанию необходимо использовать фильтры в виде строки запроса GET

$`\textcolor{green}{\text{Пример:}}`$
```
GET /api/sbp/v1/products?name=product&price=50&category=electronics
```

В исключительных случаях, сли список аргументов в фильтре слишком длинный (URL может превысить 2048 символов), 
то рекомендуем использовать для реализации фильтров запрос POST с передачей аргументов в теле запроса.

$`\textcolor{green}{\text{Правильно:}}`$  

```
POST /api/sbp/v1/products/search

{
   dateFrom="...",
   dateTo="...",
   ....
}
```

Нельзя передавать аргументы в теле запроса GET.

$`\textcolor{red}{\text{Неправильно:}}`$  

```
GET /api/sbp/v1/products
{
  "name": "product",
  "price": 50,
  "category": "electronics"
}
```

Реализация фильтров с логическими операциями or / not / ... по усмотрению исполнителя, общая рекомендация - избегать необходимости в таких фильтрах.

$`\textcolor{red}{\text{Не рекомендуем:}}`$  

```
GET /api/sbp/v1/products?or_label=A&or_label=B&label_not=C
```

---

### Используй формат даты-времени ISO 8601
| ID                       | Severity | Дата принятия |
|--------------------------|----------|---------------|
| date-time-format-iso-8601| MUST     | 18.03.2025    |

#### Описание правила

Используем формат [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601).
Избегаем использования времени / микросекунд / миллисекунд если в этом нет явной необходимости.
Принимаем в запросах время и в UTC, и с указанием чаcового пояса, возвращаем в ответе строго в формате UTC. Если в запросе нет признака UTC или указания часового пояса - возвращаем ошибку валидации.

Паттерны для даты-времени **YYYY-MM-DDThh:mm:ssZ** / **YYYY-MM-DDThh:mm:ss±hh:mm**.

Паттерн для даты **YYYY-MM-DD**.

Используем названия полей вида someData как для даты, так и для даты-времени.


$`\textcolor{green}{\text{Правильно:}}`$  

```json
"birthDate": "1980-01-30"
"qrExpirationDate": "2023-07-22T09:14:38+03:00"
"createDate": "2019-08-24T14:15:22Z"
"transactionDate": "2022-12-08T13:21:04.631543+03:00" 
```

$`\textcolor{red}{\text{Неправильно:}}`$  

```json
"birthday": "1980.01.30"
"dateTime": "2020-01-15T16:01:49.043924"
"createDateTime": "2011-03-01T14:15:22Z"
```

#### Обоснование

ISO 8601 стандарт дефакто в отрасли. Все знают и понимают этот формат, большенство ЯП использют данный формат по умолчанию для парсинга и форматирования дат.

---

### используй формат стран ISO 3166
| ID                       | Severity | Дата принятия |
|--------------------------|----------|---------------|
| country-forma-iso-3166   | MUST     | 18.03.2025    |

#### Описание правила
Формат стран [ISO 3166, UPPER ALPHA-2](https://en.wikipedia.org/wiki/ISO_3166-1).

$`\textcolor{green}{\text{Правильно:}}`$  

```json
"currency": "RUB"
```

$`\textcolor{red}{\text{Неправильно:}}`$  

```json
"currency": "643"
"currency": "Ruble"
```

#### Обоснование

ISO 3166 стандарт дефакто в отрасли. Все знают и понимают этот формат, большенство ЯП использют данный формат по умолчанию для парсинга и форматирования дат.

---

### используй формат стран ISO 4217
| ID                       | Severity | Дата принятия |
|--------------------------|----------|---------------|
| currency-format-iso-4217 | MUST     | 18.03.2025    |

#### Описание правила
Формат валют [ISO 4217, UPPER ALPHA-3](https://en.wikipedia.org/wiki/ISO_4217).

Суммы указываются как строка с дробным числом (если количество разрядов >0 ), разделитель точка, количество разрядов зависит от валюты.

Необходимо всегда указывать код валюты.


$`\textcolor{green}{\text{Правильно:}}`$  

```json
"currency": "RUB"
"amount": 1110.11
```

$`\textcolor{red}{\text{Неправильно:}}`$  

```json
"currency": "643"
"currency": "Ruble"
"sum": 1200,1
```

#### Обоснование

ISO 4217 стандарт дефакто в отрасли. Все знают и понимают этот формат, большенство ЯП использют данный формат по умолчанию для парсинга и форматирования дат.

---

### Используй версионирование в URL
| ID                      | Severity | Дата принятия |
|-------------------------|----------|---------------|
| url-versioning          | MUST     | 12.03.2025    |


#### Описание правила

Единственным способом для версионирования API является версионирование в URL. Версия должна быть указана в пути запроса, в начале метода, в формате `/v1`, `/v2` и т.д. 
```
/v1/payment-orders/{id}
```

Версия указывается в начале каждого метода API. TBD ссылка


```yaml
paths:
  /v1/payment-orders/{id}:
    post:
      ...

```


Версионирование распространяется на отдельный метод API, а не на весь API целиком. На усмотрение владельца API можно версионировать весь API целиком, это не нарушает требования к версионированию.

```yaml
paths:
  /v1/payment-orders/{id}:
    post:
      ...
  /v2/payment-orders:
    get:
      ...
```


Правильно:

```json
/v1/statements
/v2/payment-orders/
```

Неправильно:
```
/statements/v1
/payment-orders/v2/
/v1.0/statements
/payment-orders/2.0/

/statements?version=1.0


```


#### Обоснование

Версионирование API в пути запроса обеспечивает ясность и простоту управления различными версиями API. Использование формата `/v1`, `/v2` и т.д. является стандартным и широко признанным подходом, который упрощает понимание и поддержку API. 

Мы оставляем за собой большую гибкость, распространяя версию не на весь API, а на отдельный метод API. Это позволяет обновлять версию независимо для каждого метода. 
Важно, если вы понимаете, что обновление версии ведет к обратно несовместимым изменениям в рамках вашего API(набора методов), вы должны предусмотреть обновление версии связанных методов одновременно.

---

### Учитывай обратную совместимость API
| ID                                | Severity | Дата принятия |
|-----------------------------------|----------|---------------|
| versioning-backward-compatibility | MUST     | 12.03.2025    |


#### Описание правила


Изменяйте API, но сохраняйте работоспособность для всех потребителей. Потребители обычно имеют независимые релизный циклы, сосредоточены на стабильности и избегают изменений своих интеграций, которые не приносят дополнительной пользы. API - это контракт между поставщиками и потребителями услуг, который нельзя нарушить односторонними решениями.

Есть 2 способа изменения API с учетом обратной совместимости:

- Следовать правилам обратно совместимых изменений
- Выпускать новую версию метода API или API целиком

В REST API изменения могут быть ломающими (breaking changes) или обратно-совместимыми (backward-compatible changes) в зависимости от того, будут ли они нарушать существующий контракт API:

- Ломающие изменения - нарушают контракт API и могут привести к тому, что клиенты, которые ранее работали с API, перестанут работать или будут работать некорректно. Например, если изменить тип возвращаемого значения метода API, это может привести к ошибке на стороне клиента, который ожидал другой тип данных.
- Обратно-совместимые изменения - не нарушают контракт API и не приводят к сбоям на стороне клиента. Такие изменения могут включать добавление новых ресурсов, методов, параметров запросов, но не изменение или удаление существующих.

Допустимые обратно-совместимые изменения:

- Добавление новых ресурсов или методов
- Добавление необязательных параметров/полей в запрос/ответ
- Добавление новых заголовков в ответе
- Изменение порядка полей в ответе

Запрещенные ломающие изменения в рамках одной версии:

- Изменение в стандартных или кастомных заголовках ответа
- Изменение бизнес-логики методов (например, в документации описано поведение метода, но внезапно метод возвращает другой результат при неизменных входных данных)
- Изменение типов данных параметров или полей в ответе
- Удаление или переименование ресурсов, методов или полей
- Изменение регистра значений в ответе (например, "OK" вместо "ok")
- Изменение порядка или добавление/удаление/изменение элементов в перечислениях (enum)
- Добавление обязательных параметров/заголовков/полей в запрос
- Изменение порядка сортировки по умолчанию в ответе

Важно помнить, что любые изменения в API должны быть хорошо продуманы и документированны, чтобы избежать проблем совместимости и сбоев у потребителей API.


Правильно:
```json
# Добавление необязательного поля в ответ
# /v1(исходный):
{
  "id": 123,
  "name": "Product"
}

# /v1(обновленный):
{
  "id": 123,
  "name": "Product",
  "description": "Optional description"
}

```
Неправильно:
```json
# Изменение типа данных существующего поля
# /v1(исходный):
{
  "id": 123,
  "quantity": 5
}

# /v1(обновленный):
{
  "id": 123,
  "quantity": "5"
}

```

#### Обоснование

Обратная совместимость критически важна для сохранения доверия клиентов к API. Нарушение обратной совместимости может привести к сбоям в работе клиентских приложений, что влечет за собой потерю доверия к сервису и дополнительные затраты на поддержку.
Соблюдая требования к обратной совместимости, мы стремимся:
- Поддерживать существующих клиентов без изменения их кода
- Внедрять новые функции, не затрагивая работу текущих клиентов
- Предоставлять достаточное время для миграции клиентов на новые версии API

---

