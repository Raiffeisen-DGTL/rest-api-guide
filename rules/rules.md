# API Guide

- [API Guide](#api-guide)
- [Введение](#введение)
- [Общие рекомендации](#общие-рекомендации)
- [Правила](#правила)
    - [Использование kebab-case для пути](#использование-kebab-case-для-пути)
    - [Избегать избыточных префиксов в пути](#избегать-избыточных-префиксов-в-пути)
    - [Используем для именования параметров запроса camelCase](#используем-для-именования-параметров-запроса-camelcase)
    - [Используем для именования полей тела запроса camelCase](#используем-для-именования-полей-тела-запроса-camelcase)
    - [Используем camelCase для operationId метода](#используем-camelcase-для-operationid-метода)
    - [Выносим тело запроса и ответа методов в отдельный блок](#выносим-тело-запроса-и-ответа-методов-в-отдельный-блок)
    - [Объекты запросов и ответов именуются стилем PascalCase с постфиксами `Request/Response`](#объекты-запросов-и-ответов-именуются-стилем-pascalcase-с-постфиксами-requestresponse)
    - [Выделяем части запросов/ответов в отдельные объекты](#выделяем-части-запросовответов-в-отдельные-объекты)
    - [Используем UPPER\_SNAKE\_CASE для Enum и mapping для discriminator](#используем-upper_snake_case-для-enum-и-mapping-для-discriminator)
    - [Пагинация](#пагинация)
    - [Сортировка](#сортировка)
    - [Фильтрация](#фильтрация)
    - [Используй формат даты-времени ISO 8601](#используй-формат-даты-времени-iso-8601)
    - [используй формат стран ISO 3166](#используй-формат-стран-iso-3166)
    - [используй формат стран ISO 4217](#используй-формат-стран-iso-4217)
    - [Используй версионирование в URL](#используй-версионирование-в-url)
    - [Учитывай обратную совместимость API](#учитывай-обратную-совместимость-api)
    - [Соблюдайте сигнатуру пути API](#соблюдайте-сигнатуру-пути-api)
    - [Используй HTTP методы правильно](#используй-http-методы-правильно)
    - [API для скачивания файлов обязано поддерживать HEAD запрос](#api-для-скачивания-файлов-обязано-поддерживать-head-запрос)
    - [Заполняй примеры в документации](#заполняй-примеры-в-документации)
    - [Не используй статусы перенаправления запроса](#не-используй-статусы-перенаправления-запроса)
    - [Используй только наиболее распространенные коды состояния HTTP](#используй-только-наиболее-распространенные-коды-состояния-http)


# Введение

Данный гайд содержит основные принципы и правила, которым мы следуем при разработке REST API в Райффайзен Банке. 
Правила разделены по тематическим разделам.
У каждого правила есть:

- *ID* - уникальный идентификатор правила
- *Severity* - индикатор, является ли правило обязательным(MUST) или рекомендацией(RECOMMENDATION)
- *Дата принятия* - когда это правило было добавлено в гайд

# Общие рекомендации

REST ([Representational State Transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)) - это архитектурная абстракция, которая описывает взаимодействией компонентов в распределенной системе. REST широко используется для создания web API (*RESTful web API*), которое использует протокол HTTP как транспорт.

В RESTful web API обращение к ресурсу происходит по уникальному идентификатору (*URL*), с указанием действия над ресурсом (*HTTP method*), в запросе может передаваться тело запроса (*body*) и дополнительные заголовки (*HTTP header fields*). В ответ на запрос, ресурс возвращает код ответа (*HTTP status code*) и **может** возвращаться тело ответа.

В качество формата тела запроса/ответа рекомендуется использовать только JSON. Использование других форматов (XML/TXT) возможно в исключительных случаях.

Мы ориентируемся на [Richardson Maturity Model](https://martinfowler.com/articles/richardsonMaturityModel.html), но считаем избыточным Level 3

# Правила

### Использование kebab-case для пути 

| ID              | Severity | Дата принятия |
|-----------------|----------|---------------|
| path-kebab-case | MUST     | 27.02.2025    |

#### Ссылка на Spectral правило
[Ссылка на описание](../spectral/rules/openapi/README.md#path-kebab-case)  

#### Описание правила

Пути API должны использовать kebab-case (строчные буквы с разделением дефисами) для наименования.

Правильно:
```
/v1/statements
/v1/payment-orders/
```
Неправильно:
```
/v1/paymentOrders    // camelCase
/v1/PaymentOrders    // PascalCase
/v1/payment_orders   // snake_case

```
#### Обоснование

Использование kebab-case обеспечивает единообразие API и соответствует лучшим практикам именования ресурсов в REST API. 
Чтобы ваши URI было легче сканировать и интерпретировать, используйте символ дефиса (-), чтобы улучшить читаемость имен в сегментах длинных путей.

Были рассмотрены альтернативные стили именования:
- camelCase - отклонён из-за проблем с регистро-зависимостью в некоторых системах
- snake_case - отклонён для сохранения единообразия
- PascalCase - отклонён из-за проблем с читаемостью URL

---

### Избегать избыточных префиксов в пути

| ID                         | Severity | Дата принятия |
|----------------------------|----------|---------------|
| path-no-redundant-prefixes | MUST     | 27.02.2025    |


#### Ссылка на Spectral правило
[Ссылка на описание](../spectral/rules/openapi/README.md#path-no-redundant-prefixes)  

#### Описание правила

Не следует использовать избыточные термины в методах, не относящиеся к смыслу ресурса/команды, такие как:
- `api`
- `openapi`
- `http`
- `service`

> Префикс `*.raiffeisen.ru/api` или поддомен `api.raiffeisen.ru/...` допускается на уровне gateway, но не допускается в пути метода API. Подробнее см. [Следуйте структуре пути API](#следуйте-структуре-пути-api)

Правильно:
```
/v1/statements
/v1/statements/export

```

Неправильно:
```
/api/v1/statements
/v1/http/statements
/v1/statement-service/export
```

#### Обоснование

Избыточные префиксы увеличивают длину URL без добавления смысловой нагрузки, усложняют чтение и понимание API.

При публикации для внешних клиентов на `api.raiffeisen.ru` дополнительный префикс `api` будет создавать избыточность. 

---

### Используем для именования параметров запроса camelCase

| ID                      | Severity | Дата принятия |
|-------------------------|----------|---------------|
| query-params-camel-case | MUST     | 27.02.2025    |


#### Ссылка на Spectral правило
[Ссылка на описание](../spectral/rules/openapi/README.md#query-params-camel-case)  

#### Описание правила

Используем для именования параметров [camelCase](https://en.wiktionary.org/wiki/CamelCase). 


Правильно:
```
/v1/statements?requestId={requestId}
```

Неправильно:
```
/v1/statements?request_id={requestId}
/v1/statements?RequestId={requestId}
```

#### Обоснование

Самым популярным решением для query params в банке является `camelCase`, именно поэтому выбран стандартным способом именования.

---

### Используем для именования полей тела запроса camelCase

| ID                      | Severity | Дата принятия |
|-------------------------|----------|---------------|
| body-fields-camel-case  | MUST     | 11.03.2025    |


#### Ссылка на Spectral правило
[Ссылка на описание](../spectral/rules/openapi/README.md#body-fields-camel-case)  

#### Описание правила

Используем для именования полей тела запроса [camelCase](https://en.wiktionary.org/wiki/CamelCase). 


Правильно:
```json
{
  "productId": "8AD369C0-68B4-4CD2-B78B-413D53AD1E82",
  "price": 50,
  "createdAt": "2025-03-11T09:14:38+03:00"
  ...
}
```

Неправильно:
```json
{
  "product_id": "8AD369C0-68B4-4CD2-B78B-413D53AD1E82",
  "UpdatedAt": "2025-03-11T11:12:38+03:00",
  "createdat": "2025-03-11T09:14:38+03:00"
  ...
}
```

#### Обоснование

Самым популярным решением для полей тела запроса в банке является `camelCase`, именно поэтому выбран стандартным способом именования. Такое же способ именования используется в параметрах запроса - [Используем для именования параметров запроса camelCase](#используем-для-именования-параметров-запроса-camelcase)

---

### Используем camelCase для operationId метода
| ID                              | Severity | Дата принятия |
|---------------------------------|----------|---------------|
| method-operation-id-camel-case  | MUST     | 13.03.2025    |

#### Ссылка на Spectral правило
[Ссылка на описание](../spectral/rules/openapi/README.md#method-operation-id-camel-case)  

#### Описание правила

`operationId` - camelCase, содержит в себе короткое название метода (например, `createOrder` или `getPaymentStatus`).

Правильно:
```yaml
paths:
  '/sbp/v2/qrs/':
    post:
      operationId: registerQR
  ...
```

Неправильно:
```yaml
paths:
  '/sbp/v2/qrs/':
    post:
      operationId: post-sbp-v2-qrs
  ...
```

#### Обоснование
Согласно назначению в спецификации [openapi](https://swagger.io/specification/) поле может использоваться тулами и библиотеками для уникального обозначения метода в коде. Спецификация рекомендует именовать согласоно соглашения о именовании языка программирования. У нас самый популярный язык - это Java, в ней принято использовать для именования методов camelCase

---

### Выносим тело запроса и ответа методов в отдельный блок
| ID                                  | Severity | Дата принятия |
|-------------------------------------|----------|---------------|
| method-request-response-components  | MUST     | 13.03.2025    |

#### Ссылка на Spectral правило
[Ссылка на описание](../spectral/rules/openapi/README.md#method-request-response-components)  

#### Описание правила
Тело запроса и ответа должны быть вынесены в блок [Components Object](https://spec.openapis.org/oas/v3.1.0#components-object) как [Schema](https://spec.openapis.org/oas/v3.1.0#schema).

Правильно:
```yaml
paths:
  '/sbp/v2/qrs/':
    post:
      requestBody: 
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/reqPayQR'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/qrResponse'
```

Неправильно:
```yaml
paths:
  '/sbp/v2/qrs/':
    post:
      requestBody: 
        content:
          application/json:
            schema:
              type: object
              properties: 
                qrId:
                  type: string
                  ...
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: object
                properties: 
                  qrId:
                    type: string
                    ...
```
#### Обоснование
- Улучшает читаемость спецификации тогда как средства отображения АПИ в любом случае позволяют скрывать и раскрывать содержание запросов и ответов.
- Возможность переиспользования объектов запросов и ответов

---

### Объекты запросов и ответов именуются стилем PascalCase с постфиксами `Request/Response`
| ID                               | Severity           | Дата принятия |
|----------------------------------|--------------------|---------------|
| object-request-response-postfix  | RECOMMENDATION     | 13.03.2025    |

#### Ссылка на Spectral правило
[Ссылка на описание](../spectral/rules/openapi/README.md#object-request-response-postfix)  

#### Описание правила
Объекты запросов и ответов именуются стилем PascalCase с постфиксами `Request/Response` (например, `CreateOrderRequest`). Исключение составляет случай, когда модель присутствует и в запросе, и в ответе. Тогда постфикс опускается.

#### Обоснование
Улучшает читаемость и структурированность спецификации

---

### Выделяем части запросов/ответов в отдельные объекты
| ID                                  | Severity | Дата принятия |
|-------------------------------------|----------|---------------|
| object-request-response-extraction  | MUST     | 13.03.2025    |

#### Описание правила
- Все объекты, которые используются больше одного раза, должны быть вынесены как отдельные модели/параметры. Их использование происходит с помощью [ссылок](https://spec.openapis.org/oas/v3.1.0#reference-object) `$ref`.

Правильно
```yaml
    orderCreationResponse:
      properties:
        status:
          $ref: '#/components/schemas/Status'
    orderCreationResponse:
      properties:
        status:
          $ref: '#/components/schemas/Status'
    Status:
      type: object
      properties:
        value:
          type: string
          enum:
            - NEW
            - CANCELLED
            - EXPIRED
            - PAID
          description: Статус
        date:
          type: string
          format: date-time
          description: Дата создания заказа

```

Неправильно
```yaml
    orderCreationResponse:
      properties:
        status:
          type: object
          properties:
            value:
              type: string
              enum:
                - NEW
                - CANCELLED
                - EXPIRED
                - PAID
              description: Статус
            date:
              type: string
              format: date-time
              description: Дата создания заказа
    orderCreationResponse:
      properties:
        status:
          type: object
          properties:
            value:
              type: string
              enum:
                - NEW
                - CANCELLED
                - EXPIRED
                - PAID
              description: Статус
            date:
              type: string
              format: date-time
              description: Дата создания заказа
```

#### Обоснование
Следование принципу [DRY](https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself)

---

### Используем UPPER_SNAKE_CASE для Enum и mapping для discriminator
| ID                                    | Severity | Дата принятия |
|---------------------------------------|----------|---------------|
| enum-discriminator-upper-snake-case  | MUST     | 13.03.2025    |

#### Ссылка на Spectral правило
[Ссылка на описание](../spectral/rules/openapi/README.md#enum-discriminator-upper-snake-case)  

#### Описание правила
Перечисления и значения маппинга для дискриминатора именуются UPPER_SNAKE_CASE

Правильно
```yaml
properties:
  value:
    type: string
    enum:
      - NEW_ORDER
      - CANCELLED
      - EXPIRED
      - PAID
```
Неправильно
```yaml
properties:
  value:
    type: string
    enum:
      - NewOreder
      - expired-order
      - paid_order
```

#### Обоснование
В большенстве ЯП константы и перечисления именуются UPPER_SNAKE_CASE, для поддержания единобразия в спецификации стоит делать так же.

---

### Пагинация

#### Структура пагинации в отдельном объекте
| ID                        | Severity | Дата принятия |
|---------------------------|----------|---------------|
| pagination-separate-object| MUST     | 20.05.2025    |

#### Описание правила
Все параметры пагинации должны быть вынесены в отдельный объект paging для четкого разделения данных и метаинформации о пагинации.

Правильно:

```json
{
  "data": [
    {
      "id": 124,
      "name": "Product Name"
    }
  ],
  "paging": {
    "offset": 0,
    "limit": 20,
    "totalCount": 35
  }
}
```

```json
{
  "data": [
    {
      "id": 456,
      "title": "Article Title"
    }
  ],
  "paging": {
    "offset": 20,
    "limit": 10,
    "totalCount": 157
  },
  "metadata": {
    "requestId": "req-123",
    "timestamp": "2025-08-20T20:50:00Z"
  }
}
```

Неправильно:
```json
{
  "data": [
    {
      "id": 124
    }
  ],
  "offset": 0,        // Параметры пагинации смешаны с другими полями
  "limit": 20,
  "totalCount": 35
}
```

```json
{
  "data": [
    {
      "id": 124
    }
  ],
  "offset": 0,
  "limit": 20,
  "totalCount": 35,
  "metadata": {       // Сложно отличить пагинацию от других метаданных
    "requestId": "req-123"
  }
}

```

##### Обоснование

1. **Четкое разделение ответственности**: Данные (`data`) отделены от метаинформации о пагинации (`paging`)
2. **Расширяемость**: Легко добавлять новые поля пагинации без загрязнения корневого уровня
3. **Читаемость**: Разработчикам проще понимать структуру ответа
4. **Совместимость с другими метаданными**: Не конфликтует с полями типа `metadata`, `errors`, `warnings`

##### Альтернативы

- **Оставить параметры пагинации на корневом уровне**
  - Создает путаницу при добавлении других метаданных, усложняет парсинг
**Использовать объект `meta` для всех метаданных включая пагинацию**
  - Слишком общий подход, пагинация имеет специфичную семантику и заслуживает отдельного объекта

##### Ссылки на стандарты
- [JSON:API](https://jsonapi.org/format/#fetching-pagination) использует объект `meta` для метаинформации, но выделяет пагинацию в `links`

---

#### offset-пагинация
| ID                 | Severity | Дата принятия |
|--------------------|----------|---------------|
| offset-pagination  | MUST     | 13.03.2025    |

##### Описание правила

Пагинацию можно не использовать, если размер ответа не превышает 1Мб и количество элементов не больше 100. В ином случае, рекомендуется использовать курсор-пагинацию.

При использовании пагинации приоритетным вариантом является cursor-пагинация. Так как она является устойчивой к изменению данных (что важно для клиентов, выполняющих синхронизацию данных из банка со своей системой) и более производительна для больших объемов данных.

Если клиенты вашего продукта используют API не выполняя предварительное сохранение данных на своей стороне, более предпочтительной является offset-пагинация (например, напрямую выводит данные в UI).

Запрос первой страницы может быть без явного указания оффсета:

```
GET /v1/documents?limit=20
```

```json
{
  "data": [
    {
      "id": 124
    }
  ],
  "paging": {
    "offset": 0,
    "limit": 20,
    "totalCount": 35
  }
}
```

Запрос следующей страницы со значеним оффсета:

```
GET /v1/documents?limit=20&offset=20
```

Если записей больше нет, totalCount будет меньше или равен offset + limit:

```json
{
  "data": [
    {
      "id": 304
    }
  ],
  "paging": {
    "offset": 20,
    "limit": 20,
    "totalCount": 35
  }
}
```

---

#### cursor-пагинация
| ID                 | Severity | Дата принятия |
|--------------------|----------|---------------|
| cursor-pagination  | MUST     | 13.03.2025    |

##### Описание правила

Для больших или быстро меняющихся наборов данных, лучше использовать cursor-пагинацию.

Для значения курсора следует использовать уникальный индексированный набор полей.Например, дату создания записи. 

Для унификации значение курсора кодируется в base64.

Запрос без явного указания курсора вернет первые `n` записей по заданному порядку сортировки:
```
GET /sbp/v1/products?limit=20
```

Ответ должен содержать значение курсора начала следующей страницы:
```json
{
  "content": [
    {
      "id": 122
    }
  ],
  "paging": {
    "nextCursor": "ewogICAgICAiaWQiOiAxMjMKfQ=="
  }
  // Содержит 
  // {
  //       "id": 123
  // }
}
```

Запрос следующей страницы со значеним курсора:
```
GET /sbp/v1/products?cursor=ewogICAgICAiaWQiOiAxMjMKfQ==&limit=1
```

В ответ вернет:
```json
{
  "content": [
    {
      "id": 123
    }
  ],
  "paging": {
    "nextCursor": "ewogICAgICAiaWQiOiAxMjQKfQ=="
  }
  // Содержит 
  // {
  //       "id": 124
  // }
}
```
Если записей больше нет, content должен быть пустым, а nextCursor null:
```json
{
  "content": [],
  "paging": {
    "nextCursor": null
  }
}
```

При необходимости сортировки данных, их следует добавлять в курсор.
Запрос:
```
GET /sbp/v1/products?sortBy=price,name&limit=20
```
Ответ:
```json
{
  "content": [
    {
      "id": 123,
      "createdAt": "2023-07-22T09:14:38+03:00"
    }
  ],
  "paging": {
    "nextCursor": "ewogICJpZCI6IDEyNCwKICAiY3JlYXRlZEF0IjogIjIwMjMtMDctMjJUMTA6MTQ6MzgrMDM6MDAiCn0="
  }
}
```

---

### Сортировка
| ID                 | Severity | Дата принятия |
|--------------------|----------|---------------|
| sorting  | MUST     | 13.03.2025    |


#### Описание правила

В общем случае, клиент не должен полагаться на сортировку результата сервером, за исключением случаев, когда документация на API явно описывает сортировку по-умолчанию.

В случаях когда запрос возвращает небольшую выборку, более предпочтительным вариантом может оказаться сортировка на стороне клиента.

В случаях когда запрос возвращает небольшую выборку, более предпочтительным вариантом может оказаться сортировка на стороне клиента.

Если требуется сортировка по одному полю, то рекомендуем указывать поле для сортировки в параметре **sortBy** и порядок сортировки в параметре **orderBy** (asc/desc).

$`\textcolor{green}{\text{Правильно:}}`$  

```
GET /api/v1/products?sortBy=price&orderBy=desc
```

$`\textcolor{red}{\text{Неправильно:}}`$  

```
GET /api/v1/users?sort=-created_at,+username

GET /api/v1/products?sortby=price_asc&date_desc

GET /api/v1/users?sort={"created_at":"desc","username":"asc"}
```

Если параметр **orderBy** не указан, то по-умолчанию предполагается сортировка по возрастанию (*asc*).

В сложных случаях, когда требуется сортировка по нескольким полях в сочетании со сложными фильтрами и(или) пагинацией, рекомендуем использовать метод POST.

$`\textcolor{green}{\text{Рекомендуем:}}`$  

```
POST /api/v1/users/search
{
    "filter": "some filter",
    "paging": {
        "offset": 50,
        "limit": 20
    },
    "order": [
      {  "priority": 1,
         "sortBy": "created_at",
         "orderBy": "desc"
      },
      {  "priority": 2,
         "sortBy": "username",
         "orderBy": "asc"
      }
    ]
}
```

---

### Фильтрация
| ID                      | Severity | Дата принятия |
|-------------------------|----------|---------------|
| filtering               | MUST     | 18.03.2025    |

#### Описание правила

По умолчанию необходимо использовать фильтры в виде строки запроса GET

$`\textcolor{green}{\text{Пример:}}`$
```
GET /api/sbp/v1/products?name=product&price=50&category=electronics
```

В исключительных случаях, сли список аргументов в фильтре слишком длинный (URL может превысить 2048 символов), 
то рекомендуем использовать для реализации фильтров запрос POST с передачей аргументов в теле запроса.

$`\textcolor{green}{\text{Правильно:}}`$  

```
POST /api/sbp/v1/products/search

{
   dateFrom="...",
   dateTo="...",
   ....
}
```

Нельзя передавать аргументы в теле запроса GET.

$`\textcolor{red}{\text{Неправильно:}}`$  

```
GET /api/sbp/v1/products
{
  "name": "product",
  "price": 50,
  "category": "electronics"
}
```

Реализация фильтров с логическими операциями or / not / ... по усмотрению исполнителя, общая рекомендация - избегать необходимости в таких фильтрах.

$`\textcolor{red}{\text{Не рекомендуем:}}`$  

```
GET /api/sbp/v1/products?or_label=A&or_label=B&label_not=C
```

---

### Используй формат даты-времени ISO 8601
| ID                       | Severity | Дата принятия |
|--------------------------|----------|---------------|
| date-time-format-iso-8601| MUST     | 18.03.2025    |

#### Описание правила

Используем формат [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601).
Избегаем использования времени / микросекунд / миллисекунд если в этом нет явной необходимости.
Принимаем в запросах время и в UTC, и с указанием чаcового пояса, возвращаем в ответе строго в формате UTC. Если в запросе нет признака UTC или указания часового пояса - возвращаем ошибку валидации.

Паттерны для даты-времени **YYYY-MM-DDThh:mm:ssZ** / **YYYY-MM-DDThh:mm:ss±hh:mm**.

Паттерн для даты **YYYY-MM-DD**.

Используем названия полей вида someData как для даты, так и для даты-времени.


$`\textcolor{green}{\text{Правильно:}}`$  

```json
"birthDate": "1980-01-30"
"qrExpirationDate": "2023-07-22T09:14:38+03:00"
"createDate": "2019-08-24T14:15:22Z"
"transactionDate": "2022-12-08T13:21:04.631543+03:00" 
```

$`\textcolor{red}{\text{Неправильно:}}`$  

```json
"birthday": "1980.01.30"
"dateTime": "2020-01-15T16:01:49.043924"
"createDateTime": "2011-03-01T14:15:22Z"
```

#### Обоснование

ISO 8601 стандарт дефакто в отрасли. Все знают и понимают этот формат, большенство ЯП использют данный формат по умолчанию для парсинга и форматирования дат.

---

### используй формат стран ISO 3166
| ID                       | Severity | Дата принятия |
|--------------------------|----------|---------------|
| country-forma-iso-3166   | MUST     | 18.03.2025    |

#### Описание правила
Формат стран [ISO 3166, UPPER ALPHA-2](https://en.wikipedia.org/wiki/ISO_3166-1).

$`\textcolor{green}{\text{Правильно:}}`$  

```json
"currency": "RUB"
```

$`\textcolor{red}{\text{Неправильно:}}`$  

```json
"currency": "643"
"currency": "Ruble"
```

#### Обоснование

ISO 3166 стандарт дефакто в отрасли. Все знают и понимают этот формат, большенство ЯП использют данный формат по умолчанию для парсинга и форматирования дат.

---

### используй формат стран ISO 4217
| ID                       | Severity | Дата принятия |
|--------------------------|----------|---------------|
| currency-format-iso-4217 | MUST     | 18.03.2025    |

#### Описание правила
Формат валют [ISO 4217, UPPER ALPHA-3](https://en.wikipedia.org/wiki/ISO_4217).

Суммы указываются как строка с дробным числом (если количество разрядов >0 ), разделитель точка, количество разрядов зависит от валюты.

Необходимо всегда указывать код валюты.


$`\textcolor{green}{\text{Правильно:}}`$  

```json
"currency": "RUB"
"amount": 1110.11
```

$`\textcolor{red}{\text{Неправильно:}}`$  

```json
"currency": "643"
"currency": "Ruble"
"sum": 1200,1
```

#### Обоснование

ISO 4217 стандарт дефакто в отрасли. Все знают и понимают этот формат, большенство ЯП использют данный формат по умолчанию для парсинга и форматирования дат.

---

### Используй версионирование в URL
| ID                      | Severity | Дата принятия |
|-------------------------|----------|---------------|
| url-versioning          | MUST     | 12.03.2025    |

#### Ссылка на Spectral правило
[Ссылка на описание](../spectral/rules/openapi/README.md#url-versioning)  

#### Описание правила

Единственным способом для версионирования API является версионирование в URL. Версия должна быть указана в пути запроса, в начале метода, в формате `/beta`, `/v1`, `/v2` и т.д.
 
API в статусе beta могут быть изменены без обратной совместимости без уведомления.
```
/v1/payment-orders/{id}
```

Версия указывается в начале каждого метода API. TBD ссылка


```yaml
paths:
  /beta/payment-orders/{id}:
    post:
    ...
  /v1/payment-orders/{id}:
    post:
      ...

```


Версионирование распространяется на отдельный метод API, а не на весь API целиком. На усмотрение владельца API можно версионировать весь API целиком, это не нарушает требования к версионированию.

Так как присвоение номера версии API накладывает строгие правила для обратной совместимости, для новых или экспериментальных API можно использовать версию /beta, которая позволяет изменять контракт API без обратной совместимости. Потребители таких API берут на себя риски ломающих изменений и учитывают это при использовании таких API.
За исключением обратной совместимости все правила этого гайда равнозначно применяются к API с версиями `/beta`.

Рекомендуется ограничивать время существования `/beta` версии в эксплуатации и либо назначать API версию, либо выводить из эксплуатации. Рекомендуемый срок эксплуатации таких API - 1 месяц

```yaml
paths:
  /beta/payment-orders/{id}:
    post:
      ...
  /v1/payment-orders/{id}:
    post:
      ...
  /v2/payment-orders:
    get:
      ...
```


Правильно:

```json
/beta/statements
/v1/statements
/v2/payment-orders/
```

Неправильно:
```
/statements/v1
/payment-orders/v2/
/v1.0/statements
/payment-orders/2.0/

/statements?version=1.0


```


#### Обоснование

Версионирование API в пути запроса обеспечивает ясность и простоту управления различными версиями API. Использование формата `/v1`, `/v2` и т.д. является стандартным и широко признанным подходом, который упрощает понимание и поддержку API. 

Мы оставляем за собой большую гибкость, распространяя версию не на весь API, а на отдельный метод API. Это позволяет обновлять версию независимо для каждого метода. 
Важно, если вы понимаете, что обновление версии ведет к обратно несовместимым изменениям в рамках вашего API(набора методов), вы должны предусмотреть обновление версии связанных методов одновременно.

---

### Учитывай обратную совместимость API
| ID                                | Severity | Дата принятия |
|-----------------------------------|----------|---------------|
| versioning-backward-compatibility | MUST     | 12.03.2025    |


#### Описание правила


Изменяйте API, но сохраняйте работоспособность для всех потребителей. Потребители обычно имеют независимые релизный циклы, сосредоточены на стабильности и избегают изменений своих интеграций, которые не приносят дополнительной пользы. API - это контракт между поставщиками и потребителями услуг, который нельзя нарушить односторонними решениями. Иключение `/beta` версия, в рамках которой могут быть любые ломающие изменения, в любой момент времени

Есть 2 способа изменения API с учетом обратной совместимости:

- Следовать правилам обратно совместимых изменений
- Выпускать новую версию метода API или API целиком

В REST API изменения могут быть ломающими (breaking changes) или обратно-совместимыми (backward-compatible changes) в зависимости от того, будут ли они нарушать существующий контракт API:

- Ломающие изменения - нарушают контракт API и могут привести к тому, что клиенты, которые ранее работали с API, перестанут работать или будут работать некорректно. Например, если изменить тип возвращаемого значения метода API, это может привести к ошибке на стороне клиента, который ожидал другой тип данных.
- Обратно-совместимые изменения - не нарушают контракт API и не приводят к сбоям на стороне клиента. Такие изменения могут включать добавление новых ресурсов, методов, параметров запросов, но не изменение или удаление существующих.

Допустимые обратно-совместимые изменения:

- Добавление новых ресурсов или методов
- Добавление необязательных параметров/полей в запрос/ответ
- Добавление новых заголовков в ответе
- Изменение порядка полей в ответе

Запрещенные ломающие изменения в рамках одной версии(кроме версии `/beta`):

- Изменение в стандартных или кастомных заголовках ответа
- Изменение бизнес-логики методов (например, в документации описано поведение метода, но внезапно метод возвращает другой результат при неизменных входных данных)
- Изменение типов данных параметров или полей в ответе
- Удаление или переименование ресурсов, методов или полей
- Изменение регистра значений в ответе (например, "OK" вместо "ok")
- Изменение порядка или добавление/удаление/изменение элементов в перечислениях (enum)
- Добавление обязательных параметров/заголовков/полей в запрос
- Изменение порядка сортировки по умолчанию в ответе

Важно помнить, что любые изменения в API должны быть хорошо продуманы и документированны, чтобы избежать проблем совместимости и сбоев у потребителей API.


Правильно:
```json
# Добавление необязательного поля в ответ
# /v1(исходный):
{
  "id": 123,
  "name": "Product"
}

# /v1(обновленный):
{
  "id": 123,
  "name": "Product",
  "description": "Optional description"
}

```
Неправильно:
```json
# Изменение типа данных существующего поля
# /v1(исходный):
{
  "id": 123,
  "quantity": 5
}

# /v1(обновленный):
{
  "id": 123,
  "quantity": "5"
}

```

#### Обоснование

Обратная совместимость критически важна для сохранения доверия клиентов к API. Нарушение обратной совместимости может привести к сбоям в работе клиентских приложений, что влечет за собой потерю доверия к сервису и дополнительные затраты на поддержку.
Соблюдая требования к обратной совместимости, мы стремимся:
- Поддерживать существующих клиентов без изменения их кода
- Внедрять новые функции, не затрагивая работу текущих клиентов
- Предоставлять достаточное время для миграции клиентов на новые версии API

---


<!-- TODO доделать правило после обсуждения по внешним/внутренним API -->
### Соблюдайте сигнатуру пути API
| ID                      | Severity | Дата принятия |
|-------------------------|----------|---------------|
| use-correct-url-sequence            | MUST     | 12.03.2025    |


#### Описание правила

Структура URL API должна соответствовать следующему формату:

Внутренний API:
- `{поддомен}.raiffeisen.ru/v{номер версии}/{путь}`
- `{поддомен}.raiffeisen.ru/{префикс сервиса}/v{номер версии}/{путь}`

>  Методы в контракте OpenAPI всегда начинаются с номера версии - `/v1/...`. Все префиксы "слева" от версии, должны быть скрыты на gateway. Это позволяет минимизировать изменение контракта при публикации API на разные gateway.

Внешний API (публичный):
- `{поддомен}.raiffeisen.ru/{префикс продукта}/v{номер версии}/{путь}`
- `{поддомен}.raif.ru/{префикс продукта}/v1/{путь}`

Где:
- `{поддомен}` - если есть, может быть любой на усмотрение команды, в формате kebab-case. См. [Использование kebab-case для пути](#использование-kebab-case-для-пути)
- `{префикс продукта/сервиса}` - является частью URL gateway на котором размещен API. В случае с внешним API это может быть префикс продукта, чтобы разделить API разных продуктов на одном gateway. В случае с внутренним API это может быть префиксом сервиса, чтобы разделить API разных сервисов на одном gateway. На внешнем gateway где потребителям являются клиенты, не стоит в качестве префикса название сервиса, так как это не имеет смысла для клиентов, рекомендуется выбирать нейминг опираясь на продукты, а не внутренние сервисы. При выборе префикса, думайте кто ваш потребитель и какую смысловую нагрузку несет для него этот префикс. См. [Избегать избыточных префиксов в пути](#избегать-избыточных-префиксов-в-пути).
- `{номер версии}` - версия API в формате `v1`, `v2`. См. [Используй версионирование в URL](#используй-версионирование-в-url)
- `{путь}` - путь к ресурсу в формате kebab-case. См. [Использование kebab-case для пути](#использование-kebab-case-для-пути)


> В случае использования префикса продукта/сервиса избегайте использования таких же наименований в контракте методов API. Например, если в контракте метода API есть `statements`, то в префиксе и поддомене финального URL наименование `statements` не должно поворяться.

✅ Правильно (внутренний API):
- `fxo.raiffeisen.ru/api/`
- `rbp-organization-service.k8s.sme.raiffeisen.ru/v1/..`
- `uno.app.lb.k8s-p-extapp-cc-01.k8s.raiffeisen.ru/api/v1/contracts`
- `cards.raiffeisen.com/v1/statements`
- `accounts.raiffeisen.com/v1/balance`


✅ Правильно (внешний API):
- `api.raiffeisen.ru/fx/v1/trades/digest`
- `api.raiffeisen.ru/corp-cards/v1/statements`

❌ Неправильно:
- `cards.raiffeisen.com/v1/api/statements` Избыточный префикс `api`
- `payments.raiffeisen.com/v1/payments/transfers` Дублирование названия продукта в поддомене и префиксе
- `accounts.raiffeisen.com/accounts/balance/v1` Версия не в начале пути, дублирование поддомена и префикса
- `api.raiffeisen.ru/statements-service/v1/intraday` Префикс внутреннего продукта просочился на внешний gateway


#### Обоснование

Такая структура обеспечивает:
-  Единообразие формирование URL API по всему банку
-  Прозрачное версионирование
-  Чёткое разделение между продуктами/сервисами на gateway
-  Быстрый переход API от внутреннего к внешнему
-  Простоту в маршрутизации запросов к существующим продуктам
-  Наличие версии в начале пути позволяет легко определить версию API и маршрутизировать запросы к соответствующей реализации

---

### Используй HTTP методы правильно
| ID                            | Severity           | Дата принятия |
|-------------------------------|--------------------|---------------|
| use-correct-http-methods      | MUST               | 24.03.2025    |


#### Описание правила

**GET** - используется только для получения данных от сервера, не изменяет данные на сервере и не должен иметь тела запроса.

**POST** - используется для создания новых ресурсов ([см другие варианты использования](#фильтрация)), генерация идентификатора нового ресурса выполняется на стороне сервера. В общем случае **POST** не гарантирует [идемпотентность](https://en.wikipedia.org/wiki/Idempotence). Может использоваться как workaround при получении данных, в случаях когда использование GET не представляется возможным, в таком случае необходимо указывать что **POST** не создает новые сущности, а используется исключительно для получения данных.

**PUT, PATCH** - используются для изменения существующего ресурса на стороне сервера, **PUT** полностью замещает старую сущность и при его использовании в теле запроса нужно передавать все поля сущности, **PATCH** выполняет частичное изменение, при его использовании в теле запроса достаточно передать изменяемые поля.

**DELETE** - удаляет ресурс на стороне сервера.


#### GET - для получения данных
✅ Правильно:
- `/v1/accounts/{accountId}` - получение информации о конкретном счете
- `/v1/transactions?accountId=123&fromDate=2025-01-01` - получение списка транзакций по фильтрам
- `/v1/customers/{customerId}/cards` - получение списка карт клиента
- `/v1/exchange-rates/USD/RUB` - получение текущего курса валют

❌ Неправильно:
- `/v1/accounts/create` - создание нового счета через GET
- `/v1/transactions/filter` - использование GET с телом запроса для фильтрации
- `/v1/logout` - выход из системы через GET (изменяет состояние)
- `/v1/cards/block?cardId=456` - блокировка карты через GET

#### POST - для создания ресурсов
✅ Правильно:
- `/v1/accounts` - создание нового банковского счета
- `/v1/transfers` - выполнение денежного перевода
- `/v1/customers/{customerId}/cards` - выпуск новой карты

❌ Неправильно:
- `/v1/accounts/{accountId}` - получение данных о счете через POST
- `/v1/accounts/{accountId}/edit` - редактирование счета через POST (нужно использовать PUT/PATCH)
- `/v1/transfers/123/delete` - удаление перевода через POST
- `/v1/accounts/search` - поиск счетов через POST (лучше GET с параметрами)

#### PUT - для полного обновления ресурса
✅ Правильно:
- `/v1/customers/{customerId}` - полное обновление профиля клиента
- `/v1/accounts/{accountId}/settings` - замена всех настроек счета
- `/v1/cards/{cardId}` - полное обновление информации о карте
- `/v1/credit-programs/{programId}` - обновление всех параметров кредитной программы

❌ Неправильно:
- `/v1/customers/{customerId}/update` - лишнее действие в URL
- `/v1/accounts` - обновление без указания идентификатора
- `/v1/cards/{cardId}/status` - частичное обновление (использовать PATCH)
- `/v1/customers/new` - создание нового клиента через PUT

#### PATCH - для частичного обновления
✅ Правильно:
- `/v1/accounts/{accountId}` - обновление отдельных полей счета
- `/v1/cards/{cardId}/status` - изменение статуса карты
- `/v1/customers/{customerId}/address` - обновление только адреса клиента
- `/v1/loan/{loanId}/schedule` - корректировка графика платежей по кредиту

❌ Неправильно:
- `/v1/accounts/{accountId}/change-status` - лишнее действие в URL
- `/v1/cards/all` - массовое обновление без указания конкретного ресурса
- `/v1/customers/{customerId}/delete-data` - удаление данных через PATCH
- `/v1/accounts/{accountId}/full-update` - полное обновление через PATCH

#### DELETE - для удаления ресурсов
✅ Правильно:
- `/v1/accounts/{accountId}` - закрытие/удаление счета
- `/v1/customers/{customerId}/consents/{consentId}` - отзыв согласия на обработку данных
- `/v1/cards/{cardId}` - удаление карты
- `/v1/scheduled-payments/{paymentId}` - отмена запланированного платежа

❌ Неправильно:
- `/v1/accounts/close` - действие без идентификатора ресурса
- `/v1/cards/{cardId}/block` - блокировка карты через DELETE (использовать PATCH)
- `/v1/authentication/logout` - выход из системы через DELETE
- `/v1/transactions/{transactionId}/refund` - возврат транзакции через DELETE

#### Обоснование

Правильное использование HTTP методов критически важно для создания интуитивно понятных, предсказуемых и соответствующих стандартам REST API. В финансовой среде, где безопасность и надежность имеют первостепенное значение, следование этим правилам особенно важно по следующим причинам:
1. Семантическая ясность - Каждый метод HTTP имеет четко определенное назначение, что делает API интуитивно понятным для разработчиков. Правильное использование методов автоматически документирует предназначение эндпоинта.
2. Безопасность системы - Методы GET предполагаются безопасными и не должны изменять состояние системы. Это критично для предотвращения непреднамеренных изменений в банковских системах через такие операции как кеширование или индексация.
3. Идемпотентность операций - GET, PUT и DELETE должны быть идемпотентными (многократное выполнение дает тот же результат), что особенно важно при повторных запросах или восстановлении после сбоев.
4. Правильное кеширование - Корректное использование методов позволяет промежуточным системам (прокси, CDN) правильно кешировать ответы, что улучшает производительность и снижает нагрузку.
5. Совместимость с инструментами и фреймворками - Стандартные инструменты разработки и тестирования ожидают соответствия HTTP методов их стандартному назначению.

Неправильное использование HTTP методов может привести к:
- Непредсказуемому поведению кеширующих систем
- Проблемам безопасности (например, изменение данных через GET-запросы)
- Затруднениям при отладке и тестировании
- Несовместимости с API-шлюзами и средствами защиты
- Нарушению пользовательского опыта для потребителей API
- Техническому долгу и сложностям при масштабировании системы
Соблюдение этого правила является фундаментальным для создания надежного, безопасного и легко сопровождаемого API.

### API для скачивания файлов обязано поддерживать HEAD запрос 
| ID                  | Severity       | Дата принятия | 
|---------------------|----------------|---------------|
| provide-head-method | RECOMMENDATION | 07.04.2025    |

#### Ссылка на Spectral правило
[Ссылка на описание](../spectral/rules/openapi/README.md#provide-head-method)  

#### Описание правила

API для скачивания какого-либо файла должно поддерживать метод **HEAD**

#### Обоснование
**HEAD** - запрашивает заголовки, идентичные тем, что возвращаются, если указанный ресурс будет запрошен с помощью HTTP-метода GET. Запрос может быть выполнен перед загрузкой ресурса, например, для кэширования, по заголовкам `ETag` или `Last-Modified`, или узнать размер файла без скачивания по заголовку `Content-Length`

---
### Заполняй примеры в документации
| ID                            | Severity           | Дата принятия |
|-------------------------------|--------------------|---------------|
| valid-schema-example          | MUST               | 24.03.2025    |

#### Ссылка на Spectral правило
[Ссылка на описание](../spectral/rules/openapi/README.md#valid-schema-example)  


#### Описание правила

[Примеры](https://swagger.io/docs/specification/adding-examples/) очень важны. Когда формируется OpenAPI спецификация, необходимо для каждого запроса/ответа операции определить примеры. То же самое применимо для опеределений указанных в ссылках, например компонентах.

[Примеры](https://swagger.io/docs/specification/adding-examples/) помогают потребителю вашего API понять, как должны выглядеть реальные данные, когда мы отправляем запрос или получаем ответ.
Хорошие примеры очень ценны, когда данные сложные, вложенные или содержат специальное форматирование.

Примеры должны быть в:
- Запросах операций
- Ответах операций
- Параметрах операций
- Глобальных компонентах
- Глобальных параметрах
- В массивах и для элементов массива

В версии OpenAPI 3.0, нужно включать примеры для каждого [RequestBody](https://swagger.io/docs/specification/describing-request-body/). Также нужно добавлять примеры для [Responses](https://swagger.io/docs/specification/describing-responses/), [Components](https://swagger.io/docs/specification/components/) или [Parameters](hhttps://swagger.io/docs/specification/describing-parameters/).

✅ Правильно:
```yaml
paths:
  /v1/accounts/{accountId}:
    get:
      operationId: getAccount
      summary: Получение информации о счете
      parameters:
        - name: accountId
          in: path
          required: true
          schema:
            type: string
          examples:
            primaryAccount:
              summary: Пример ID основного счета
              value: '40817810099910004312'
            cardAccount:
              summary: Пример ID карточного счета
              value: '40817810099910004333'
      responses:
        '200':
          description: Информация о счете успешно получена
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Account'
              examples:
                savingsAccount:
                  summary: Пример сберегательного счета
                  value:
                    accountId: '40817810099910004312'
                    type: 'savings'
                    currency: 'RUB'
                    balance: 150000.00
                    status: 'active'
                    openDate: '2023-05-15'
                    interestRate: 5.5
                cardAccount:
                  summary: Пример дебетового карточного счета
                  value:
                    accountId: '40817810099910004333'
                    type: 'debit'
                    currency: 'RUB'
                    balance: 75430.25
                    status: 'active'
                    openDate: '2022-11-03'
                    cards: [
                      {
                        cardId: '5469440012345678',
                        expiryDate: '02/26',
                        status: 'active'
                      }
                    ]

  /v1/transfers:
    post:
      operationId: createTransfer
      summary: Выполнение денежного перевода
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TransferRequest'
            examples:
              domesticTransfer:
                summary: Пример внутреннего перевода
                value:
                  sourceAccountId: '40817810099910004312'
                  destinationAccountId: '40817810099910004333'
                  amount: 15000.00
                  currency: 'RUB'
                  description: 'Перевод на карту'
              swiftTransfer:
                summary: Пример международного SWIFT-перевода
                value:
                  sourceAccountId: '40817810099910004312'
                  destinationBIC: 'CHASUS33'
                  destinationAccountId: '36003588120300'
                  amount: 1000.00
                  currency: 'USD'
                  description: 'Payment for services'
                  recipientName: 'John Smith'
                  recipientAddress: '123 Main St, New York, USA'
      responses:
        '201':
          description: Перевод успешно создан
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TransferResponse'
              examples:
                successfulTransfer:
                  summary: Пример успешного перевода
                  value:
                    transferId: 'TRF-2025-03-24-123456'
                    status: 'completed'
                    timestamp: '2025-03-24T14:30:45Z'
                    fee: 0.00
                pendingTransfer:
                  summary: Пример перевода на обработке
                  value:
                    transferId: 'TRF-2025-03-24-123457'
                    status: 'pending'
                    timestamp: '2025-03-24T14:35:22Z'
                    estimatedCompletionTime: '2025-03-24T15:00:00Z'
                    fee: 150.00

components:
  schemas:
    Account:
      type: object
      properties:
        accountId:
          type: string
          example: '40817810099910004312'
        type:
          type: string
          enum: [savings, checking, credit, debit]
          example: 'savings'
        currency:
          type: string
          example: 'RUB'
        balance:
          type: number
          format: double
          example: 150000.00
        status:
          type: string
          enum: [active, blocked, closed]
          example: 'active'
        openDate:
          type: string
          format: date
          example: '2023-05-15'
      required:
        - accountId
        - type
        - currency
        - balance
        - status
  
  parameters:
    DateRangeFrom:
      name: fromDate
      in: query
      description: Начало периода для выборки данных
      schema:
        type: string
        format: date
      examples:
        lastMonth:
          summary: Пример начала прошлого месяца
          value: '2025-02-01'
        currentYear:
          summary: Пример начала текущего года
          value: '2025-01-01'
```
❌ Неправильно:

```yaml
paths:
  /v1/accounts/{accountId}:
    get:
      operationId: getAccount
      summary: Получение информации о счете
      parameters:
        - name: accountId
          in: path
          required: true
          schema:
            type: string
          # Отсутствуют примеры параметра
      responses:
        '200':
          description: Информация о счете успешно получена
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Account'
              # Отсутствуют примеры ответа

  /v1/transfers:
    post:
      operationId: createTransfer
      summary: Выполнение денежного перевода
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TransferRequest'
            # Отсутствуют примеры запроса
      responses:
        '201':
          description: Перевод успешно создан
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TransferResponse'
              # Отсутствуют примеры ответа

components:
  schemas:
    Account:
      type: object
      properties:
        accountId:
          type: string
          # Отсутствует пример поля
        type:
          type: string
          enum: [savings, checking, credit, debit]
          # Отсутствует пример поля
        # Остальные поля также без примеров

```


#### Обоснование

Пользователь начинает свое взаимодействие с API с контракта. Хорошо задокументированный контракт, позволяет быстрее интегрироваться с вашим API. Независимо от того, для каких целей вы делаете API, API First предполагает, что вы начинаете разработку вашего API именно с контракта и сразу можете заложить необходимую документацию. 

При отсутствии документации, ваш контракт потребуется дорабатывать в момент публикации на клиентов/пользователей, поэтому рекомендуется закладывать документацию на самых ранних этапах создания спецификации.

Так же example/examples используются различными инструментами рендеринга и кодогенерации, поэтому отсутствие некоторых примеров, может сломать эти инструменты.

---
### Не используй статусы перенаправления запроса
| ID                            | Severity           | Дата принятия |
|-------------------------------|--------------------|---------------|
| not-use-redirection-codes    | RECOMMENDATION      |   24.03.2025  |

#### Ссылка на Spectral правило
[Ссылка на описание](../spectral/rules/openapi/README.md#not-use-redirection-codes)  

#### Описание правила
 
Не используй коды редиректа для API(кроме **304**, который безопасен и на самом деле не redirect код). Обычно коды редиректа используются, чтобы перенаправить запрос клиента в новое место, где развернут ваш сервис. Тем не менее, это лучше решается одним из следующих способов:

- Изменить клиентов, дав им возможность мигрировать на новый адрес, при этом избегая необходимость редиректов.
- Перенаправлять трафик на сетевом уровне(gateway, reverse proxy), без необходимости вовлекать клиента.
- Deprecation эндпоинта и вывод из эксплуатации


#### Обоснование

Так как существуют более надежные решения для миграции потребителей на другой адрес, следует избегать применения redirect кодов. 
Есть еще ряд причин почему не стоит использовать redirect коды:
- Клиенты API `!=` Браузер - браузеры автоматически следуют редиректам, а backend-клиенты(мобильные приложения, сервисы) - нет.  
- Проблемы с аутентификацией(OAuth, JWT, API-ключи) - при редиректах если клиент не передаст авторизационный токен в новый URL -> запрос сломается
- Неожиданные проблемы с HTTP-методами - **301**, **302** могут не сохранаять HTTP-метод(`POST`->`GET`). **307**, **308** сохраняют метод, но **клиенты API не всегда их поддерживают**. Следовательно ломается логика API
- Разные библиотеки по-разному работают с редиректами - curl(по умолчанию не следует редиректам на POST), Java HttpClient(может терять заголовки), Python reqeuest(меняет `POST` на `GET` при 301/302)


---
### Используй только наиболее распространенные коды состояния HTTP 
| ID                            | Severity           | Дата принятия |
|-------------------------------|--------------------|---------------|
| use-most-common-http-codes    | RECOMMENDATION     |   25.03.2025  |

#### Ссылка на Spectral правило
[Ссылка на описание](../spectral/rules/openapi/README.md#use-most-common-http-codes)  

#### Описание правила

Наиболее часто используемые коды являются более понятными и перечислены ниже как подмножество официальных кодов состояния HTTP и при этом соответствуют их семантике в RFC.
Мы избегаем менее часто используемых кодов, которые легко могут вызвать неверные представления из-за менее знакомой семантики и специфических интерпретаций API.

#### Легенда

<span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  

Общий, хорошо понятный код состояния, который следует использовать там, где это необходимо. Это НЕ означает, что каждая операция должна возвращать этот код.

<span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌ Не используй</span>

Мы не видим подходящего случая для возврата этого кода состояния из RESTful API. Код состояния может быть применим в других контекстах, например, возвращаться обратными прокси-серверами, для веб-страниц и т. д. Неявно также означает <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span>, поскольку коды состояния, которые не возвращаются API, также не должны документироваться.

<span style="background-color: #006400; color: white; padding: 2px 5px; border-radius: 3px;">✅ Документируй</span>  

Если код состояния может быть возвращен API, он должен быть задокументирован в спецификации API.

<span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span>

Код статуса имеет хорошо понятное стандартное значение, поэтому документируйте его только в том случае, если вы хотите добавить какие-то специфические детали.

#### Успешные коды

##### 200 OK 
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-200-ok) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #006400; color: white; padding: 2px 5px; border-radius: 3px;">✅ Документируй</span> `<all>`

Это наиболее общий ответ на успешное выполнение запроса. Его следует использовать, если более конкретные коды ниже неприменимы.

##### 201 Created
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-201-created) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #006400; color: white; padding: 2px 5px; border-radius: 3px;">✅ Документируй</span> `POST`, `PUT`

Возвращается при успешном создании ресурса. **201** возвращается как с телом ответа, так и без него (в отличие от **200** / **204**).

##### 202 Accepted
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-202-accepted) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #006400; color: white; padding: 2px 5px; border-radius: 3px;">✅ Документируй</span> `POST`, `PUT`, `PATCH`, `DELETE`

Запрос был успешным и будет обработан асинхронно. Применяется только к методам, которые что-то изменяют.

##### 204 No content
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-204-no-content) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #006400; color: white; padding: 2px 5px; border-radius: 3px;">✅ Документируй</span> `POST`, `PUT`, `PATCH`, `DELETE`

Возвращается вместо 200, если нет тела ответа. Обычно применяется только для методов, которые что-то изменяют.

##### 205 Reset Content
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-205-reset-content) <span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌  Не используй</span> `<all>`

Это предназначено для интерактивных случаев использования, например, для очистки формы после ее отправки. Нет никаких причин использовать его в REST API.

##### 206 Partial Content
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-206-partial-content) <span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌  Не используй</span> `<all>`

Для ответов на запросы диапазона, когда возвращается только часть ресурса, указанная диапазоном байтов. Это не относится к пагинации, где следует использовать обычный 200. Этот статус полезен для API, которые работают с файлами и потоковыми данными, но не нужен для обычных REST API.

##### 207 Multi-Status
[RFC](https://datatracker.ietf.org/doc/html/rfc4918#section-11.1) <span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌  Не используй</span> `<all>`

Возвращается когда один запрос затрагивает **несколько ресурсов**, и для каждого из них необходимо вернуть **разный статус выполнения**. Не рекомендуем использовать этот код ответа, так как изнчально он является расширением из WebDAV архитектуры, которая плохо ложится на традиционный REST API. При использовании статуса **207** важно контроллировать потребителя, потому что такой статус создает сложность при обработке ошибок.
Для batch-загрузки лучше использовать [200 OK](#200-ok) статус с массивом результатов для каждого объекта.

#### Перенаправление(redirect)

##### 301 Moved Permanently
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-301-moved-permanently) <span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌  Не используй</span> `<all>`

Этот и все последующие запросы должны быть направлены на указанный URI. См. [Не используй статусы перенаправления запроса](#не-используй-статусы-перенаправления-запроса)

##### 302 Found
[RFC](https://tools.ietf.org/html/rfc9110#name-302-found) <span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌  Не используй</span> `<all>`

Это временное перенаправление, при котором некоторые http клиенты могут изменить метод запроса с `POST` на `GET`. В основном используется для перенаправления отправленных форм в браузерах. См. [Не используй статусы перенаправления запроса](#не-используй-статусы-перенаправления-запроса)

##### 303 See Other
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-303-see-other) <span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌  Не используй</span> `POST`, `PUT`, `PATCH`, `DELETE`

Ответ на запрос может быть найден по другому URI с использованием метода GET. Альтернативная версия **302** для случая, когда клиент должен изменить метод на GET. См. [Не используй статусы перенаправления запроса](#не-используй-статусы-перенаправления-запроса)

##### 304 Not Modified
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-304-not-modified) <span style="background-color: #006400; color: white; padding: 2px 5px; border-radius: 3px;">✅ Документируй</span> `GET`, `HEAD`

Это специальный HTTP-код, который означает, что **ресурс не изменился с момента последнего запроса клиента**. Этот статус используется **только с кешированными данными.**. Когда клиент запрашивает ресурс, он может отправить заголовки `If-Modified-Since` или `If-None-Match`, указывающие на то, что у него уже есть кешированная версия. Если сервер видит, что ресурс **не изменился** jy djpdhfoftn **304 Not Modified**, а клиент использует свою кешированную версию. Для запросов `PUT`, `PATCH`, `DELETE` вместо этого используйте **412** статус ответа.


##### 307 Temporary Redirect
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-307-temporary-redirect) <span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌  Не используй</span> `<all>`

Ответ на запрос может быть найден по другому URI. Альтернативная версия **302**, в которой клиент должен сохранить тот же метод, что и в исходном запросе. См. [Не используй статусы перенаправления запроса]

##### 308 Permanent Redirect
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-308-permanent-redirect) <span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌  Не используй</span> `<all>`

Аналогично **307**, но клиент должен навсегда сохранить новый URI. Применимо скорее к браузерам. См. [Не используй статусы перенаправления запроса]

#### Ошибки клиента

##### 400 Bad Request
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-400-bad-request) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #006400; color: white; padding: 2px 5px; border-radius: 3px;">✅ Документируй</span> `<all>`

Неспецифическая ошибка клиента, указывающая на то, что сервер не может обработать запрос из-за чего-то, что воспринимается как ошибка клиента (например, неправильный синтаксис запроса, не валидный запрос). Должна также передаваться в случае, если тело запроса не прошло проверку бизнес-логики / семантики (вместо использования **422**).

##### 401 Unauthorized
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-401-unauthorized) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span> `<all>`

Фактически означает **Unauthenticated**. Учетные данные отсутствуют или недействительны для целевого ресурса. Для API это обычно означает, что предоставленный токен или cookie не действительны. Поскольку такое может произойти почти с каждым endpoint-ом, API обычно не должны документировать это.


##### 403 Forbidden
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-403-forbidden) <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span> `<all>`

Означает, что **сервер принимает запрос, но отказывает в доступе из-за недостаточных прав или политик сервиса**. Для API это может означать, что токен запроса был действительным, но в нем отсутствовал scope для данного endpoint-а. Или что не удалось выполнить какую-то специфическую для объекта авторизацию. Мы рекомендуем для этого кода документировать только второй случай.

Также этот код ответа может трактоваться не верно, в связке с другими **4**** кодами. А еще есть риск утечки информации, который может дать понять злоумышленнику что ресурс существует.
Ниже таблица когда какой код рекомендуется использовать:
| Ситуация                              | Код ответа        | Причина                                     |
|---------------------------------------|-------------------|---------------------------------------------|
| Клиент не передал `Authorization`     | `401 Unauthorized`| Запрос требует аутентификации               |
| Клиент передал неверный токен         | `401 Unauthorized`| Аутентификация провалена                    |
| Клиент залогинен, но не имеет доступа | `403 Forbidden`   | У пользователя недостаточно прав            |
| Клиент запрашивает чужие данные       | `404 Not Found`   | Политика API запрещает доступ               |
| Ресурса не существует или скрыт       | `404 Not Found`   | Защита от утечек информации                 |


##### 404 Not found
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-404-not-found) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span> `<all>`

Целевой ресурс не найден. Этот код ответа будет возвращен большинством путей в большинстве API (без документации), а также для endpoint-ов с параметрами в запросе, когда эти параметры не могут быть сопоставлены с существующей сущностью на сервере. Для `PUT` endpoint-ов, которые поддерживают только обновление существующих ресурсов, этот код может быть возвращен, если ресурс не существует. За исключением этих особых случаев, этот статус не нужно документировать.

##### 405 Method Not Allowed
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-405-method-not-allowed) <span style="background-color: #006400; color: white; padding: 2px 5px; border-radius: 3px;">✅ Документируй</span> `<all>`

Метод запроса не поддерживается для данного ресурса. Теоретически, этот код может быть возвращен для всех ресурсов для всех методов, кроме тех, которые задокументированы. Использование этого кода ответа для существующего endpoint-а (обычно с параметрами пути) имеет смысл только в том случае, если от внутреннего состояния ресурса зависит, разрешен ли определенный метод, например, заказ можно отменить только через `DELETE`, пока груз не покинет склад. 

**Не используйте этот статус код, если у вас нет специального случая, но тогда обязательно документируйте его, чтобы было понятно, почему ресурс может не поддерживать тот или иной метод.**

##### 406 Not Acceptable
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-406-not-acceptable) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span> `<all>`

Сервер не может вернуть данные в формате, который клиент указал в заголовке `Accept`.

##### 408 Request timeout
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-408-request-timeout) <span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌  Не используй</span> `<all>`

Сервер не получил полный запрос от клиента за отведенное время. Для API этот код использовать не стоит.

##### 409 Conflict
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-409-conflict) <span style="background-color: #006400; color: white; padding: 2px 5px; border-radius: 3px;">✅ Документируй</span> `POST`, `PUT`, `PATCH`, `DELETE`

Запрос не может быть выполнен из-за конфликта с текущим состоянием ресурса. Например, при попытке создать ресурс, который уже существует. Или конфликты возникающие при редактировании ресурса, который изменился с момента последнего получения, тогда можно вернуть **409** как индикатор того, что клиенту нужно повторно запросить данные перед обновлением. 

Если такой способ используется, он должен быть задокументирован. Для успешного надежного создания ресурсов (PUT или POST) вы всегда должны возвращать **200** или **201**, а не **409**, даже если ресурс уже существует. Если какие-либо заголовки `If-*` вызывают конфликт, вы должны использовать **412**, а не **409**. Применимо только к методам, которые что-то изменяют.

##### 410 Gone
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-410-gone) <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span> `<all>`

Ресурса больше не существует. Он существовал в прошлом и, скорее всего, не будет существовать в будущем. Это может использоваться, например, при доступе к ресурсу, который был намеренно удален. Обычно это не нужно документировать, если только нет особой необходимости отличать этот случай от обычного **404**.

##### 411 Length Required
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-411-length-required) <span style="background-color: #006400; color: white; padding: 2px 5px; border-radius: 3px;">✅ Документируй</span> `POST`, `PUT`, `PATCH`

Серверу требуется заголовок `Content-Length` для этого запроса. Обычно это актуально только для загрузки больших файлов. Соответствующий заголовок должен быть отмечен как обязательный. Если он используется, он должен быть документирован.

##### 412 Precondition Failed
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-412-precondition-failed) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span> `PUT`, `PATCH`, `DELETE`

Возвращается для условных запросов, например, `If-Match`, если условие не выполнилось. Используется для оптимистичной блокировки. Обычно применяется только к методам, которые что-то изменяют. Для запросов `HEAD`, `GET` вместо этого используйте **304**.

##### 415 Unsupported Media Type
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-415-unsupported-media-type) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span> `POST`, `PUT`, `PATCH`

Клиент не предоставил поддерживаемый `Content-Type` для тела запроса. Применимо только к методам с телом запроса.

##### 417 Expectation Failed
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-417-expectation-failed) <span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌  Не используй</span> `<all>`

Возвращается, если клиент использовал заголовок `Expect`, который сервер не поддерживает. Единственное определенная ценность для заголовка `Expect` является очень технической и не относится к API.

##### 418 I’m a teapot 🫖
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-418-unused) <span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌  Не используй</span> `<all>`

Используйте только в том случае, если вы реализуете API для чайника, который не поддерживает заваривание кофе. Этот код является первоапрельской шуткой из [RFC 2324](https://www.rfc-editor.org/rfc/rfc2324.html). Его не стоит использовать в API.

##### 422 Unprocessable Content
[RFC](https://tools.ietf.org/html/rfc9110#name-422-unprocessable-content) <span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌  Не используй</span> `<all>`

Сервер понимает тип содержимого, но не может его обработать. Мы не рекомендуем использовать этот код, так как **400** уже покрывает большинство случаев использования, и, кажется, нет явной пользы от различия между ними.

##### 423 Locked
[RFC](https://datatracker.ietf.org/doc/html/rfc4918#section-11.3) <span style="background-color: #006400; color: white; padding: 2px 5px; border-radius: 3px;">✅ Документируй</span> `PUT`, `PATCH`, `DELETE`


Пессимистичная блокировка, например, состояния обработки. Может использоваться для указания существующей блокировки ресурса, однако мы рекомендуем использовать оптимистичную блокировку. Если используется, то должно быть документировано, чтобы указать на пессимистичную блокировку.

##### 424 Failed Dependency
[RFC](https://datatracker.ietf.org/doc/html/rfc4918#section-11.4) <span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌  Не используй</span> `<all>`

Запрос завершился неудачей из-за отказа предыдущего запроса. Это не относится к RESTful API.

##### 428 Precondition Required
[RFC](https://datatracker.ietf.org/doc/html/rfc6585#section-7.1) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span> `<all>`

Используется для обозначения ситуации, когда сервер требует выполнения предварительного условия перед выполнением запроса, например для избежания проблемы "lost update", когда клиент может попытаться изменить ресурс, при этом не получив последнюю его версию. Вместо документирования этого кода ответа, добавляйте в документацию используемые заголовки для таких сценариев.

Для большинства сценариев с обычным API предпочтительнее использовать стандартные коды ошибок, такие как **409** или другие более простые подходы для управления состоянием.


##### 429 Too many requests
[RFC](https://datatracker.ietf.org/doc/html/rfc6585#section-7.2) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span> `<all>`

Используется для указания на то, что клиент отправил слишком много запросов за ограниченный период времени и должен замедлить свои запросы.


##### 431 Request Header Fields Too Large
[RFC](https://datatracker.ietf.org/doc/html/rfc6585#section-7.3) <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span> `<all>`

Сервер не может обработать запрос из-за слишком большого размера заголовков запроса. Обычно используется шлюзами и прокси-серверами с ограничениями по объему памяти.


#### Ошибки сервера


##### 500 Internal Server Error
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-500-internal-server-error) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span> `<all>`

Общий признак ошибки, связанной с непредвиденной проблемой выполнения сервера. Клиенты должны быть осторожны с повторными попытками при получении этого ответа, поскольку природа проблемы неизвестна и возможно повторится.

##### 501 Not Implemented
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-501-not-implemented) <span style="background-color: #006400; color: white; padding: 2px 5px; border-radius: 3px;">✅ Документируй</span> `<all>`

Сервер не может выполнить запрос, поскольку endpoint еще не реализован. Обычно это подразумевает доступность в будущем, но повторять попытку запроса сейчас не рекомендуется. Может быть задокументировано для endpoint-ов, которые планируется реализовать в будущем, чтобы указать, что они пока недоступны.

##### 502 Bad Gateway
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-502-bad-gateway) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span> `<all>`

Этот статус может быть возвращен автоматически вашим API Gateway или балансировщиком нагрузки (например, Nginx) при проблемах с бэкендом. Может использоваться сервером для указания на то, что входящий сервис выдает неожиданный результат вместо **500**. Клиенты должны быть осторожны с повторными попытками при получении этого ответа, поскольку природа проблемы неизвестна и возможно повторится.

Но не стоит вручную выставлять **502** в коде вашего приложения. Внутренние ошибки лучше обрабатывать и отдавать **503 Service Unavailable** с указанием **Retry-After**.


##### 503 Service Unavailable
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-503-service-unavailable) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span> `<all>`

Сервис (временно) недоступен. Клиенту рекомендуется повторять запросы по экспоненциальной схеме. Если возможно, сервис должен указать, как долго клиент должен ждать, установив заголовок **Retry-After**.

##### 504 Gateway Timeout 
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#name-504-gateway-timeout) <span style="background-color: #008000; color: white; padding: 2px 5px; border-radius: 3px;">✅ Используй</span>  <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span> `<all>`

Означает, что сервер-шлюз(например, API-Gateway, прокси или балансировщик нагрузки) **не дождался ответа от бэкенд-сервера в установленный таймаут.

Но не стоит вручную выставлять **504** в коде вашего приложения. Внутренние ошибки лучше обрабатывать и отдавать **503 Service Unavailable** с указанием **Retry-After**.

##### 505 HTTP Version Not Supported 
[RFC](https://datatracker.ietf.org/doc/html/rfc9110#section-15.6.6) <span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌  Не используй</span> `<all>`

Сервер не поддерживает версию протокола HTTP, использованную в запросе. Технический код ответа, который не используется в RESTful API.

##### 507 Insufficient Storage
[RFC](https://datatracker.ietf.org/doc/html/rfc4918#section-11.5) <span style="background-color: #DAA520; color: black; padding: 2px 5px; border-radius: 3px;">⚠️ Не документируй</span> `POST`, `PUT`, `PATCH`

Сервер не может сохранить ресурс, необходимый для выполнения запроса. Может использоваться для указания на то, что на сервере закончилось дисковое пространство.

##### 511 Network Authentication Required
[RFC](https://datatracker.ietf.org/doc/html/rfc6585#section-7.4) <span style="background-color: #B22222; color: white; padding: 2px 5px; border-radius: 3px;">❌  Не используй</span> `<all>`

Клиенту необходимо пройти аутентификацию, чтобы получить доступ к сети. Технический код ответа, который не используется в RESTful API.


