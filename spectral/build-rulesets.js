#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const yaml = require('js-yaml')

console.log('Generating rulesets...')

// Function to create header for ruleset files
function createHeader(outputFile) {
  // Determine the ruleset type based on the output file name
  let documentationUrl = 'https://gitlabci.raiffeisen.ru/cib/api-guide/-/tree/master/spectral/rules'

  if (outputFile.includes('asyncapi')) {
    documentationUrl += '/asyncapi'
  } else {
    documentationUrl += '/openapi'
  }

  const header = `# AUTOGENERATED - DO NOT EDIT THIS FILE MANUALLY
documentationUrl: ${documentationUrl}
`
  fs.writeFileSync(outputFile, header)
}

// Function to load YAML file
function loadYamlFile(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8')
    return yaml.load(content) || {}
  } catch (error) {
    console.error(`Error loading YAML file ${filePath}:`, error.message)
    process.exit(1)
  }
}

// Simple merge function that combines objects
function mergeObjects(objects) {
  const result = {}

  for (const obj of objects) {
    // Merge each object into result
    for (const key in obj) {
      // Skip x-rulesets field as it's only used for organizing rulesets
      if (key === 'x-rulesets') {
        continue
      }

      if (obj.hasOwnProperty(key)) {
        if (
          key === 'rules' &&
          result[key] &&
          typeof result[key] === 'object' &&
          typeof obj[key] === 'object' &&
          !Array.isArray(obj[key])
        ) {
          // Special handling for rules - merge the rule objects
          result[key] = { ...result[key], ...obj[key] }
        } else if (key === 'functions' && Array.isArray(result[key]) && Array.isArray(obj[key])) {
          // Special handling for functions - concatenate arrays and remove duplicates
          const combined = [...result[key], ...obj[key]]
          result[key] = [...new Set(combined)]
        } else if (
          key === 'aliases' &&
          result[key] &&
          typeof result[key] === 'object' &&
          typeof obj[key] === 'object' &&
          !Array.isArray(obj[key])
        ) {
          // Special handling for aliases - merge the alias objects
          result[key] = { ...result[key], ...obj[key] }
        } else {
          // For other keys, just overwrite/assign
          result[key] = obj[key]
        }
      }
    }
  }

  return result
}

// Function to remove duplicates from arrays
function removeArrayDuplicates(arr) {
  if (!Array.isArray(arr)) return arr

  const seen = new Set()
  const result = []

  for (const item of arr) {
    // For objects/arrays, we need to stringify to compare
    const itemKey =
      typeof item === 'object' && item !== null
        ? JSON.stringify(item, Object.keys(item).sort())
        : item

    if (!seen.has(itemKey)) {
      seen.add(itemKey)
      result.push(item)
    }
  }

  return result
}

// Function to recursively remove duplicates in all arrays
function removeDuplicates(obj) {
  if (Array.isArray(obj)) {
    // Process each item in the array
    const processedArray = obj.map((item) => removeDuplicates(item))
    return removeArrayDuplicates(processedArray)
  } else if (obj && typeof obj === 'object') {
    // Process each property of the object
    const result = {}
    for (const [key, value] of Object.entries(obj)) {
      result[key] = removeDuplicates(value)
    }
    return result
  }

  return obj
}

// Function to sort object keys alphabetically
function sortKeys(obj) {
  if (Array.isArray(obj)) {
    // If array, sort each element
    return obj.map((item) => sortKeys(item))
  } else if (obj && typeof obj === 'object') {
    // If object, sort keys and recursively sort values
    const sortedKeys = Object.keys(obj).sort()
    const sortedObj = {}

    for (const key of sortedKeys) {
      sortedObj[key] = sortKeys(obj[key])
    }

    return sortedObj
  }

  return obj
}

// Function to remove functionsDir property
function removeFunctionsDir(obj) {
  if (Array.isArray(obj)) {
    return obj.map((item) => removeFunctionsDir(item))
  } else if (obj && typeof obj === 'object' && obj !== null) {
    // Create a copy without functionsDir
    const result = {}
    for (const [key, value] of Object.entries(obj)) {
      if (key !== 'functionsDir') {
        result[key] = removeFunctionsDir(value)
      }
    }
    return result
  }

  return obj
}

// Custom YAML dumper
function customYamlDump(obj) {
  return yaml.dump(obj, {
    lineWidth: -1,
    quotingType: '"',
    forceQuotes: true, // Force all strings to be quoted
    skipInvalid: false,
    noRefs: true,
  })
}

// Function to build ruleset using JavaScript
function buildRulesetWithJS(inputFiles, outputFile) {
  console.log(`Building ${path.basename(outputFile)}...`)

  // Create header
  createHeader(outputFile)

  // Load all YAML files
  const yamlObjects = inputFiles.map((file) => loadYamlFile(file))

  // Merge all objects
  let merged = mergeObjects(yamlObjects)

  // Remove duplicates in arrays
  merged = removeDuplicates(merged)

  // Sort keys alphabetically
  merged = sortKeys(merged)

  // Remove functionsDir property
  merged = removeFunctionsDir(merged)

  // Convert to YAML
  let yamlStr = customYamlDump(merged)

  // Post-process to fix specific formatting to match yq output exactly
  // Fix extends format
  yamlStr = yamlStr.replace(
    'extends:\n  - - "spectral:oas"\n    - "off"',
    "extends: [['spectral:oas', off]]",
  )

  yamlStr = yamlStr.replace(
    'extends:\n  - - "spectral:asyncapi"\n    - "off"',
    "extends: [['spectral:asyncapi', off]]",
  )

  // Append to output file
  fs.appendFileSync(outputFile, yamlStr)

  console.log(`Successfully built ${path.basename(outputFile)}`)
}

// Function to get all rule files from a specified directory
function getAllRuleFiles(scriptDir, apiType) {
  const ruleFiles = []
  const apiDir = path.join(scriptDir, 'rules', apiType)

  // Recursively find all yaml files in the API directory
  function walkDir(dir) {
    const files = fs.readdirSync(dir)
    for (const file of files) {
      const filePath = path.join(dir, file)
      const stat = fs.statSync(filePath)
      if (stat.isDirectory()) {
        walkDir(filePath)
      } else if (file.endsWith('.yaml') || file.endsWith('.yml')) {
        ruleFiles.push(filePath)
      }
    }
  }

  walkDir(apiDir)
  return ruleFiles.sort()
}

// Function to extract tags from a rule file
function getTagsFromFile(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8')
    const doc = yaml.load(content) || {}
    return doc['x-rulesets'] || []
  } catch (error) {
    console.error(`Error reading tags from ${filePath}:`, error.message)
    return []
  }
}

// Function to group files by tags
function groupFilesByTags(files) {
  const tagGroups = {}

  for (const file of files) {
    const tags = getTagsFromFile(file)
    for (const tag of tags) {
      if (!tagGroups[tag]) {
        tagGroups[tag] = []
      }
      tagGroups[tag].push(file)
    }
  }

  return tagGroups
}

// Get the directory of this script
const scriptDir = path.join(__dirname)

// Get all OpenAPI rule files
const allOpenAPIRuleFiles = getAllRuleFiles(scriptDir, 'openapi')

// Group files by tags
const tagGroups = groupFilesByTags(allOpenAPIRuleFiles)

// Build ruleset for each tag
for (const [tag, files] of Object.entries(tagGroups)) {
  const outputFile = path.join(scriptDir, `${tag}-ruleset.yaml`)
  buildRulesetWithJS(files, outputFile)
}

// Get all AsyncAPI rule files
const allAsyncAPIRuleFiles = getAllRuleFiles(scriptDir, 'asyncapi')

// Group AsyncAPI files by tags
const asyncTagGroups = groupFilesByTags(allAsyncAPIRuleFiles)

// Build AsyncAPI ruleset for each tag with asyncapi- prefix
for (const [tag, files] of Object.entries(asyncTagGroups)) {
  const outputFile = path.join(scriptDir, `asyncapi-${tag}-ruleset.yaml`)
  buildRulesetWithJS(files, outputFile)
}

// Add generated files to git
try {
  const generatedFiles = Object.keys(tagGroups).map((tag) => `${tag}-ruleset.yaml`)
  // Add AsyncAPI rulesets with asyncapi- prefix
  Object.keys(asyncTagGroups).forEach((tag) => {
    generatedFiles.push(`asyncapi-${tag}-ruleset.yaml`)
  })
  require('child_process').execSync(`git add ${generatedFiles.join(' ')}`, { stdio: 'inherit' })
} catch (error) {
  console.warn('Could not add files to git:', error.message)
}

console.log('Rulesets generated successfully!')
