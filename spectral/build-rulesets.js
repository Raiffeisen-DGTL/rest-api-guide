#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const yaml = require('js-yaml')

console.log('Generating rulesets...')

// Function to create header for ruleset files
function createHeader(outputFile) {
  // Determine the ruleset type based on the output file name
  let documentationUrl = 'https://gitlabci.raiffeisen.ru/cib/api-guide/-/tree/master/spectral/rules'

  if (outputFile.includes('asyncapi')) {
    documentationUrl += '/asyncapi'
  } else {
    documentationUrl += '/openapi'
  }

  const header = `# AUTOGENERATED - DO NOT EDIT THIS FILE MANUALLY
documentationUrl: ${documentationUrl}
`
  fs.writeFileSync(outputFile, header)
}

// Function to load YAML file
function loadYamlFile(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8')
    return yaml.load(content) || {}
  } catch (error) {
    console.error(`Error loading YAML file ${filePath}:`, error.message)
    process.exit(1)
  }
}

// Simple merge function that combines objects
function mergeObjects(objects) {
  const result = {}

  for (const obj of objects) {
    // Merge each object into result
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        if (
          key === 'rules' &&
          result[key] &&
          typeof result[key] === 'object' &&
          typeof obj[key] === 'object' &&
          !Array.isArray(obj[key])
        ) {
          // Special handling for rules - merge the rule objects
          result[key] = { ...result[key], ...obj[key] }
        } else if (key === 'functions' && Array.isArray(result[key]) && Array.isArray(obj[key])) {
          // Special handling for functions - concatenate arrays and remove duplicates
          const combined = [...result[key], ...obj[key]]
          result[key] = [...new Set(combined)]
        } else if (
          key === 'aliases' &&
          result[key] &&
          typeof result[key] === 'object' &&
          typeof obj[key] === 'object' &&
          !Array.isArray(obj[key])
        ) {
          // Special handling for aliases - merge the alias objects
          result[key] = { ...result[key], ...obj[key] }
        } else {
          // For other keys, just overwrite/assign
          result[key] = obj[key]
        }
      }
    }
  }

  return result
}

// Function to remove duplicates from arrays
function removeArrayDuplicates(arr) {
  if (!Array.isArray(arr)) return arr

  const seen = new Set()
  const result = []

  for (const item of arr) {
    // For objects/arrays, we need to stringify to compare
    const itemKey =
      typeof item === 'object' && item !== null
        ? JSON.stringify(item, Object.keys(item).sort())
        : item

    if (!seen.has(itemKey)) {
      seen.add(itemKey)
      result.push(item)
    }
  }

  return result
}

// Function to recursively remove duplicates in all arrays
function removeDuplicates(obj) {
  if (Array.isArray(obj)) {
    // Process each item in the array
    const processedArray = obj.map((item) => removeDuplicates(item))
    return removeArrayDuplicates(processedArray)
  } else if (obj && typeof obj === 'object') {
    // Process each property of the object
    const result = {}
    for (const [key, value] of Object.entries(obj)) {
      result[key] = removeDuplicates(value)
    }
    return result
  }

  return obj
}

// Function to sort object keys alphabetically
function sortKeys(obj) {
  if (Array.isArray(obj)) {
    // If array, sort each element
    return obj.map((item) => sortKeys(item))
  } else if (obj && typeof obj === 'object') {
    // If object, sort keys and recursively sort values
    const sortedKeys = Object.keys(obj).sort()
    const sortedObj = {}

    for (const key of sortedKeys) {
      sortedObj[key] = sortKeys(obj[key])
    }

    return sortedObj
  }

  return obj
}

// Function to remove functionsDir property
function removeFunctionsDir(obj) {
  if (Array.isArray(obj)) {
    return obj.map((item) => removeFunctionsDir(item))
  } else if (obj && typeof obj === 'object' && obj !== null) {
    // Create a copy without functionsDir
    const result = {}
    for (const [key, value] of Object.entries(obj)) {
      if (key !== 'functionsDir') {
        result[key] = removeFunctionsDir(value)
      }
    }
    return result
  }

  return obj
}

// Custom YAML dumper
function customYamlDump(obj) {
  return yaml.dump(obj, {
    lineWidth: -1,
    quotingType: '"',
    forceQuotes: true, // Force all strings to be quoted
    skipInvalid: false,
    noRefs: true,
  })
}

// Function to build ruleset using JavaScript
function buildRulesetWithJS(inputFiles, outputFile) {
  console.log(`Building ${path.basename(outputFile)}...`)

  // Create header
  createHeader(outputFile)

  // Load all YAML files
  const yamlObjects = inputFiles.map((file) => loadYamlFile(file))

  // Merge all objects
  let merged = mergeObjects(yamlObjects)

  // Remove duplicates in arrays
  merged = removeDuplicates(merged)

  // Sort keys alphabetically
  merged = sortKeys(merged)

  // Remove functionsDir property
  merged = removeFunctionsDir(merged)

  // Convert to YAML
  let yamlStr = customYamlDump(merged)

  // Post-process to fix specific formatting to match yq output exactly
  // Fix extends format
  yamlStr = yamlStr.replace(
    'extends:\n  - - "spectral:oas"\n    - "off"',
    "extends: [['spectral:oas', off]]",
  )

  yamlStr = yamlStr.replace(
    'extends:\n  - - "spectral:asyncapi"\n    - "off"',
    "extends: [['spectral:asyncapi', off]]",
  )

  // Append to output file
  fs.appendFileSync(outputFile, yamlStr)

  console.log(`Successfully built ${path.basename(outputFile)}`)
}

// Get the directory of this script
const scriptDir = path.join(__dirname)

// Get required rule files
const requiredFiles = fs
  .readdirSync(path.join(scriptDir, 'rules', 'openapi', 'required'))
  .filter((file) => file.endsWith('.yaml') || file.endsWith('.yml'))
  .map((file) => path.join(scriptDir, 'rules', 'openapi', 'required', file))
  .sort()

// Build required ruleset
buildRulesetWithJS(requiredFiles, path.join(scriptDir, 'required-ruleset.yaml'))

// Get AsyncAPI required rule files
const asyncRequiredFiles = fs
  .readdirSync(path.join(scriptDir, 'rules', 'asyncapi', 'required'))
  .filter((file) => file.endsWith('.yaml') || file.endsWith('.yml'))
  .map((file) => path.join(scriptDir, 'rules', 'asyncapi', 'required', file))
  .sort()

// Build AsyncAPI required ruleset
buildRulesetWithJS(asyncRequiredFiles, path.join(scriptDir, 'asyncapi-required-ruleset.yaml'))

// Get base rule files (required + base)
const baseFiles = [
  ...requiredFiles,
  ...fs
    .readdirSync(path.join(scriptDir, 'rules', 'openapi', 'base'))
    .filter((file) => file.endsWith('.yaml') || file.endsWith('.yml'))
    .map((file) => path.join(scriptDir, 'rules', 'openapi', 'base', file))
    .sort(),
]

// Build base ruleset
buildRulesetWithJS(baseFiles, path.join(scriptDir, 'base-ruleset.yaml'))

// Add generated files to git
try {
  require('child_process').execSync(
    'git add base-ruleset.yaml required-ruleset.yaml asyncapi-required-ruleset.yaml',
    { stdio: 'inherit' },
  )
} catch (error) {
  console.warn('Could not add files to git:', error.message)
}

console.log('Rulesets generated successfully!')
